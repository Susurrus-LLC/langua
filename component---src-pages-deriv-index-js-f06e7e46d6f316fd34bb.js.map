{"version":3,"sources":["webpack:///./src/pages/deriv/deriv.module.sass","webpack:///./src/pageComponents/deriv/derivForm.js","webpack:///./src/pageComponents/deriv/derivResults.js","webpack:///./src/services/derivService.js","webpack:///./src/pages/deriv/index.js"],"names":["module","exports","DerivForm","styles","data","change","filePicker","React","createRef","lexemeRows","lexemes","map","lexeme","index","key","className","derivRow","type","id","name","lexemeInput","value","onChange","aria-label","lexemeDefInput","definition","clearButton","onClick","ver","small","derivationRows","derivations","derivation","derivationInput","derivationGlossInput","gloss","derivationDefInput","addButton","which","addingRow","classNames","sharedStyles","part","sectionTitle","columnLabel","wordLabel","definitionLabel","affixLabel","glossLabel","addedClasses","side","htmlFor","min","max","wordsInput","words","e","preventDefault","current","click","hidden","ref","DerivResults","possible","results","useState","hovered","setHovered","outputBox","item","i","term","affixGloss","hoveredGloss","onMouseOver","hoverAffix","onMouseOut","unhoverAffix","lexGloss","error","output","newWords","length","newWord","outputRow","rowNumber","prefix","suffix","affixDef","hoveredDef","stats","statsText","toLocaleString","derivService","this","getData","bind","save","open","setStorage","add","clear","changeInput","derive","dataProcessor","fileProcessor","file","callback","response","window","FileReader","openFile","result","endsWith","lexemeSchema","schema","String","derivationSchema","DataSchema","Number","Array","of","content","JSON","parse","toast","success","autoClose","bodyClassName","progressClassName","warn","console","errors","newData","stringify","push","num","splice","val","wordNumChange","filter","remaining","affix","replace","test","match","circum","split","attachAffix","base","Math","floor","random","list","randInd","randAff","deriveFromSingleBase","der","randLex","deriveFromSingleDerivation","getUniqueItem","newItem","isUnique","deriveFromAny","PureDeriv","toolInfo","site","siteMetadata","deriv","setWords","setType","setLexemes","setDerivations","setResults","state","target","tagName","slice","idNum","files","Deriv","props","useStaticQuery"],"mappings":"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","file":"component---src-pages-deriv-index-js-f06e7e46d6f316fd34bb.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"wordsInput\":\"deriv-module--words-input--2bmq4\",\"derivRow\":\"deriv-module--deriv-row--1yw_v\",\"addingRow\":\"deriv-module--adding-row--3Cxlq\",\"outputRow\":\"deriv-module--output-row--2uhRT\",\"columnLabel\":\"deriv-module--column-label--2sxe8\",\"lexemeInput\":\"deriv-module--lexeme-input--1q6iO\",\"wordLabel\":\"deriv-module--word-label--1_VEw\",\"derivationGlossInput\":\"deriv-module--derivation-gloss-input--3lpct\",\"glossLabel\":\"deriv-module--gloss-label--3QhJP\",\"lexemeDefInput\":\"deriv-module--lexeme-def-input--1PyjP\",\"definitionLabel\":\"deriv-module--definition-label--3ocQV\",\"derivationDefInput\":\"deriv-module--derivation-def-input--34fIT\",\"derivationInput\":\"deriv-module--derivation-input--37Q2P\",\"affixLabel\":\"deriv-module--affix-label--2g9m4\",\"outputBox\":\"deriv-module--output-box--hM7ft\",\"rowNumber\":\"deriv-module--row-number--1HlZQ\",\"term\":\"deriv-module--term--35vHL\",\"gloss\":\"deriv-module--gloss--1d-oE\",\"lexGloss\":\"deriv-module--lex-gloss--1hQV4\",\"affixGloss\":\"deriv-module--affix-gloss--3b5ra\",\"affixDef\":\"deriv-module--affix-def--2NkCo\",\"hoveredGloss\":\"deriv-module--hovered-gloss--1tYhZ\",\"hoveredDef\":\"deriv-module--hovered-def--1n_qF\"};","import React from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Form from '../../components/form'\nimport Button from '../../components/button'\nimport Control from '../../components/control'\nimport ControlSide from '../../components/control/side'\nimport ControlPiece from '../../components/control/piece'\n\nimport sharedStyles from '../../components/form/sharedForm.module.sass'\n\nconst DerivForm = ({ styles, data, change }) => {\n  const filePicker = React.createRef()\n\n  const lexemeRows = data.lexemes.map((lexeme, index) => (\n    <div key={index} className={styles.derivRow}>\n      <input\n        type='text'\n        id={`lw${index}`}\n        name={`lw${index}`}\n        className={styles.lexemeInput}\n        value={lexeme.lexeme}\n        onChange={change}\n        aria-label={`Word for lexeme ${index}`}\n      />\n      <input\n        type='text'\n        id={`ld${index}`}\n        name={`ld${index}`}\n        className={styles.lexemeDefInput}\n        value={lexeme.definition}\n        onChange={change}\n        aria-label={`Gloss for lexeme ${index}`}\n      />\n      <div className={styles.clearButton}>\n        <Button\n          id={`lc${index}`}\n          onClick={change}\n          ver='danger'\n          small\n          type='button'\n          aria-label={`Delete lexeme ${index}`}\n        >\n          Delete\n        </Button>\n      </div>\n    </div>\n  ))\n\n  const derivationRows = data.derivations.map((derivation, index) => (\n    <div key={index} className={styles.derivRow}>\n      <input\n        type='text'\n        id={`da${index}`}\n        name={`da${index}`}\n        className={styles.derivationInput}\n        value={derivation.derivation}\n        onChange={change}\n        aria-label={`Affix ${index}`}\n      />\n      <input\n        type='text'\n        id={`dl${index}`}\n        name={`dl${index}`}\n        className={styles.derivationGlossInput}\n        value={derivation.gloss}\n        onChange={change}\n        aria-label={`Gloss for affix ${index}`}\n      />\n      <input\n        type='text'\n        id={`dd${index}`}\n        name={`dd${index}`}\n        className={styles.derivationDefInput}\n        value={derivation.definition}\n        onChange={change}\n        aria-label={`Definition for affix ${index}`}\n      />\n      <div className={styles.clearButton}>\n        <Button\n          id={`dc${index}`}\n          onClick={change}\n          ver='danger'\n          small\n          type='button'\n          aria-label={`Delete lexeme ${index}`}\n        >\n          Delete\n        </Button>\n      </div>\n    </div>\n  ))\n\n  const addButton = which => (\n    <div className={styles.addingRow}>\n      <Button\n        onClick={change}\n        id={`${which}Add`}\n        ver='success'\n        small\n        type='button'\n      >\n        Add\n      </Button>\n    </div>\n  )\n\n  const invokeFilePicker = e => {\n    e.preventDefault()\n    filePicker.current.value = ''\n    filePicker.current.click()\n  }\n\n  return (\n    <Form name='deriv-form'>\n      <div className={classNames(styles.lexemes, sharedStyles.part)}>\n        <h5 className={sharedStyles.sectionTitle}>Lexemes</h5>\n        <div className={styles.derivRow}>\n          <h6 className={classNames(styles.columnLabel, styles.wordLabel)}>\n            Word\n          </h6>\n          <h6\n            className={classNames(styles.columnLabel, styles.definitionLabel)}\n          >\n            Gloss\n          </h6>\n        </div>\n        {lexemeRows}\n        {addButton('lex')}\n      </div>\n      <div className={classNames(styles.derivations, sharedStyles.part)}>\n        <h5 className={sharedStyles.sectionTitle}>Derivational Affixes</h5>\n        <div className={styles.derivRow}>\n          <h6 className={classNames(styles.columnLabel, styles.affixLabel)}>\n            Affix\n          </h6>\n          <h6 className={classNames(styles.columnLabel, styles.glossLabel)}>\n            Gloss\n          </h6>\n          <h6\n            className={classNames(styles.columnLabel, styles.definitionLabel)}\n          >\n            Definition\n          </h6>\n        </div>\n        {derivationRows}\n        {addButton('der')}\n      </div>\n      <Control addedClasses={sharedStyles.part}>\n        <ControlSide side='left'>\n          <ControlPiece>\n            <Button type='submit' ver='neutral' onClick={change}>\n              Derive\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <label htmlFor='words'>number of words to derive:</label>\n            <input\n              type='number'\n              id='words'\n              name='words'\n              min='1'\n              max='9999'\n              className={styles.wordsInput}\n              value={data.words}\n              onChange={change}\n            />\n          </ControlPiece>\n          <ControlPiece>\n            <label htmlFor='type'>output type:</label>\n            <select id='type' name='type' value={data.type} onChange={change}>\n              <option value='any'>any base, any derivation</option>\n              <option value='single base'>single base</option>\n              <option value='single derivation'>single derivation</option>\n            </select>\n          </ControlPiece>\n        </ControlSide>\n        <ControlSide side='right'>\n          <ControlPiece>\n            <Button id='save' ver='success' onClick={change} type='button'>\n              Save\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <Button id='open' onClick={invokeFilePicker} type='button'>\n              Open\n            </Button>\n            <input\n              id='file'\n              name='file'\n              className={sharedStyles.hidden}\n              type='file'\n              ref={filePicker}\n              onChange={change}\n            />\n          </ControlPiece>\n        </ControlSide>\n      </Control>\n    </Form>\n  )\n}\n\nDerivForm.propTypes = {\n  styles: PropTypes.object,\n  data: PropTypes.shape({\n    words: PropTypes.number.isRequired,\n    type: PropTypes.oneOf(['any', 'single base', 'single derivation'])\n      .isRequired,\n    lexemes: PropTypes.arrayOf(\n      PropTypes.shape({\n        lexeme: PropTypes.string.isRequired,\n        definition: PropTypes.string.isRequired\n      })\n    ),\n    derivations: PropTypes.arrayOf(\n      PropTypes.shape({\n        derivation: PropTypes.string.isRequired,\n        gloss: PropTypes.string.isRequired,\n        definition: PropTypes.string.isRequired\n      })\n    )\n  }).isRequired,\n  change: PropTypes.func.isRequired\n}\n\nexport default DerivForm\n","import React, { useState } from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Results from '../../components/results'\n\nimport sharedStyles from '../../components/results/sharedResults.module.sass'\n\nconst DerivResults = ({ styles, results }) => {\n  const [hovered, setHovered] = useState(null)\n  const outputBox = (which, item, i) => {\n    if (which === 'affix') {\n      return (\n        <div className={styles.outputBox}>\n          <p className={styles.term}>{item.derivation}</p>\n          <p\n            className={classNames(\n              styles.affixGloss,\n              styles.gloss,\n              // Dynamically assign the hovered class if hovered\n              i === hovered ? styles.hoveredGloss : null\n            )}\n            onMouseOver={() => hoverAffix(i)}\n            onMouseOut={() => unhoverAffix(i)}\n          >\n            {item.gloss}\n          </p>\n        </div>\n      )\n    } else if (which === 'lexeme') {\n      return (\n        <div className={styles.outputBox}>\n          <p className={styles.term}>{item.lexeme}</p>\n          <p className={classNames(styles.lexGloss, styles.gloss)}>\n            {item.definition}\n          </p>\n        </div>\n      )\n    } else if (which === 'error') {\n      return (\n        <div className={styles.outputBox}>\n          <p className={classNames(sharedStyles.error, styles.gloss)}>{item}</p>\n        </div>\n      )\n    } else {\n      return null\n    }\n  }\n\n  const output = () => {\n    if (results) {\n      if (results.newWords.length) {\n        return results.newWords.map((newWord, i) => (\n          <div\n            key={i}\n            className={classNames(styles.derivRow, styles.outputRow)}\n          >\n            <div className={classNames(styles.outputBox, styles.rowNumber)}>\n              {i + 1}.\n            </div>\n            <div>\n              <div className={classNames(styles.derivRow, styles.outputRow)}>\n                {newWord.prefix ? outputBox('affix', newWord.prefix, i) : null}\n                {newWord.lexeme ? outputBox('lexeme', newWord.lexeme, i) : null}\n                {newWord.suffix ? outputBox('affix', newWord.suffix, i) : null}\n                {newWord.error ? outputBox('error', newWord.error, i) : null}\n              </div>\n              <p\n                className={classNames(\n                  styles.affixDef,\n                  // Dynamically assign the hovered class if hovered\n                  i === hovered ? styles.hoveredDef : null\n                )}\n              >\n                {newWord.prefix\n                  ? newWord.prefix.definition\n                  : newWord.suffix\n                  ? newWord.suffix.definition\n                  : ''}\n              </p>\n            </div>\n          </div>\n        ))\n      }\n    }\n\n    return null\n  }\n\n  const statsText = () => {\n    let words = 0\n    let possible = 0\n\n    if (results) {\n      words = results.newWords.length.toLocaleString()\n      possible = results.possible.toLocaleString()\n    }\n\n    return `words: ${words}; maximum derivations possible: ${possible}`\n  }\n\n  const hoverAffix = i => {\n    setHovered(i)\n  }\n\n  const unhoverAffix = i => {\n    setHovered(null)\n  }\n\n  return (\n    <Results>\n      <div className={styles.output}>{output()}</div>\n      <div className={sharedStyles.stats}>\n        <p className={sharedStyles.statsText}>{statsText()}</p>\n      </div>\n    </Results>\n  )\n}\n\nDerivResults.propTypes = {\n  styles: PropTypes.object,\n  results: PropTypes.shape({\n    newWords: PropTypes.arrayOf(\n      PropTypes.shape({\n        lexeme: PropTypes.shape({\n          lexeme: PropTypes.string.isRequired,\n          definition: PropTypes.string.isRequired\n        }).isRequired,\n        prefix: PropTypes.shape({\n          derivation: PropTypes.string.isRequired,\n          gloss: PropTypes.string.isRequired,\n          definition: PropTypes.string.isRequired\n        }),\n        suffix: PropTypes.shape({\n          derivation: PropTypes.string.isRequired,\n          gloss: PropTypes.string.isRequired,\n          definition: PropTypes.string.isRequired\n        }),\n        error: PropTypes.string\n      })\n    ),\n    possible: PropTypes.number\n  })\n}\n\nexport default DerivResults\n","import { toast } from 'react-toastify'\nimport schema from 'js-schema'\n\nimport dataProcessor from '../tools/dataProcessor'\nimport fileProcessor from '../tools/fileProcessor'\n\nclass DerivService {\n  constructor () {\n    this.item = 'deriv'\n    this.getData = this.getData.bind(this)\n    this.save = this.save.bind(this)\n    this.open = this.open.bind(this)\n    this.setStorage = this.setStorage.bind(this)\n    this.add = this.add.bind(this)\n    this.clear = this.clear.bind(this)\n    this.changeInput = this.changeInput.bind(this)\n    this.derive = this.derive.bind(this)\n  }\n\n  // Get the data from storage or from the default data\n  getData () {\n    return dataProcessor.getData(this.item)\n  }\n\n  // Store the current data in storage\n  setStorage (data) {\n    dataProcessor.setStorage(data, this.item)\n  }\n\n  // Save the current state to storage and generate a file\n  save (data) {\n    fileProcessor.save(data, this.item)\n  }\n\n  // Open a file and parse it to restore a saved state\n  open (file, callback) {\n    let response\n\n    const processResults = result => {\n      // If correct filetype\n      if (file.name.endsWith('.lngd')) {\n        // Define correct file structure\n        const lexemeSchema = schema({\n          lexeme: String,\n          definition: String\n        })\n\n        const derivationSchema = schema({\n          derivation: String,\n          gloss: String,\n          definition: String\n        })\n\n        const DataSchema = schema({\n          words: Number,\n          type: ['any', 'single base', 'single derivation'],\n          lexemes: Array.of(lexemeSchema),\n          derivations: Array.of(derivationSchema)\n        })\n\n        const content = JSON.parse(result)\n\n        if (content.results) {\n          content.results.words = +content.results.words\n        }\n\n        if (DataSchema(content)) {\n          // If the file's content contains valid Data, load it\n          toast.success(`Data loaded from ${file.name}.`, {\n            autoClose: 5000,\n            className: 'toast-opened',\n            bodyClassName: 'toast-opened-body',\n            progressClassName: 'toast-opened-progress'\n          })\n\n          this.setStorage(content)\n\n          response = content\n        } else {\n          // If the file's content does not contain valid Data, show an error\n          toast.warn(`The content of ${file.name} is invalid.`, {\n            autoClose: 5000,\n            className: 'toast-unopened',\n            bodyClassName: 'toast-unopened-body',\n            progressClassName: 'toast-unopened-progress'\n          })\n\n          // eslint-disable-next-line\n          console.error(DataSchema.errors(content))\n\n          response = false\n        }\n      } else {\n        // If incorrect filetype\n        toast.warn('Wrong filetype selected.', {\n          autoClose: 5000,\n          className: 'toast-unopened',\n          bodyClassName: 'toast-unopened-body',\n          progressClassName: 'toast-unopened-progress'\n        })\n\n        response = false\n      }\n\n      callback(response)\n    }\n\n    if (window.FileReader) {\n      // If the browser has access to the File APIs, open the file\n      fileProcessor.openFile(file, processResults)\n    } else {\n      // If the browser can't access the File APIs, display a notification\n      toast.warn('Your browser is unable to open files.', {\n        autoClose: 5000,\n        className: 'toast-unopened',\n        bodyClassName: 'toast-unopened-body',\n        progressClassName: 'toast-unopened-progress'\n      })\n\n      response = false\n      callback(response)\n    }\n  }\n\n  // Add a new row to the form\n  add (data, which) {\n    const newData = JSON.parse(JSON.stringify(data))\n    if (which === 'lex') {\n      newData.lexemes.push({ lexeme: '', definition: '' })\n    } else {\n      newData.derivations.push({ derivation: '', gloss: '', definition: '' })\n    }\n    return newData\n  }\n\n  // Remove a row from the form\n  clear (data, num, which) {\n    const newData = JSON.parse(JSON.stringify(data))\n    if (which === 'l') {\n      newData.lexemes.splice(num, 1)\n    } else {\n      newData.derivations.splice(num, 1)\n    }\n    return newData\n  }\n\n  // Update an input field\n  changeInput (data, num, which, val) {\n    const newData = JSON.parse(JSON.stringify(data))\n    switch (which) {\n      case 'lw':\n        newData.lexemes[num].lexeme = val\n        break\n      case 'ld':\n        newData.lexemes[num].definition = val\n        break\n      case 'da':\n        newData.derivations[num].derivation = val\n        break\n      case 'dl':\n        newData.derivations[num].gloss = val\n        break\n      case 'dd':\n        newData.derivations[num].definition = val\n        break\n      default:\n        break\n    }\n    return newData\n  }\n\n  // When the number of desired words is changed, create a new version of state\n  wordNumChange (data, val) {\n    val = +val\n    // Limit number entry to between 1 and 9999\n    if (val < 1) {\n      val = 1\n    } else if (val > 9999) {\n      val = 9999\n    }\n\n    // Only change state if the number is between 1 and 9999\n    if (val > 0 && val < 10000) {\n      const newData = JSON.parse(JSON.stringify(data))\n      newData.words = val\n      return newData\n    } else {\n      // Otherwise, keep state the same\n      return false\n    }\n  }\n\n  // Derive words from the data\n  derive (data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    // Compute the total possible number of results\n    const computePossible = filter => {\n      if (filter === 'single base') {\n        return newData.derivations.length\n      } else if (filter === 'single derivation') {\n        return newData.lexemes.length\n      } else {\n        return newData.lexemes.length * newData.derivations.length\n      }\n    }\n    const possible = computePossible(newData.type)\n    // If the user has selected to derive more than the total number possible, limit the results to the number that is possible\n    let remaining = newData.words > possible ? possible : newData.words\n\n    // Classify each of the affixes\n    const derivations = newData.derivations.map(affix => {\n      affix.derivation = affix.derivation.replace(/-+/g, '-')\n      if (/-/.test(affix.derivation)) {\n        // If the affix entered contains a hyphen\n        if (affix.derivation.match(/-/g).length === 1) {\n          // If the affix entered caintains no more than one hyphen\n          if (/-$/.test(affix.derivation)) {\n            // Prefix\n            affix.gloss = `${affix.gloss}-`\n            return { prefix: affix }\n          } else if (/^-/.test(affix.derivation)) {\n            // Suffix\n            affix.gloss = `-${affix.gloss}`\n            return { suffix: affix }\n          } else {\n            // Circumfix\n            const circum = affix.derivation.split(/-/)\n            const prefix = JSON.parse(JSON.stringify(affix))\n            const suffix = JSON.parse(JSON.stringify(affix))\n            prefix.derivation = `${circum[0]}-`\n            prefix.gloss = `${prefix.gloss}-`\n            suffix.derivation = `-${circum[1]}`\n            suffix.gloss = `-${suffix.gloss}`\n            return { prefix: prefix, suffix: suffix }\n          }\n        } else {\n          // If the affix entered contains more than one hyphen\n          return {\n            error: `The affix ${affix.derivation} contains too many hyphens.`\n          }\n        }\n      } else {\n        // If the affix entered contains no hyphens\n        return { error: `The affix ${affix.derivation} is missing a hyphen.` }\n      }\n    })\n\n    // Attach words to their affixes on the correct side(s)\n    const attachAffix = (lexeme, affix) => {\n      return {\n        prefix: affix.prefix,\n        lexeme: lexeme,\n        suffix: affix.suffix,\n        error: affix.error\n      }\n    }\n\n    // Derive from a single base\n    const deriveFromSingleBase = () => {\n      const base =\n        newData.lexemes[Math.floor(Math.random() * newData.lexemes.length)]\n      const list = []\n      while (remaining > 0) {\n        const randInd = Math.floor(Math.random() * derivations.length)\n        const randAff = derivations[randInd]\n        list.push(attachAffix(base, randAff))\n        derivations.splice(randInd, 1)\n        remaining--\n      }\n      return list\n    }\n\n    // Derive from a single derivation\n    const deriveFromSingleDerivation = () => {\n      const der = derivations[Math.floor(Math.random() * derivations.length)]\n      const list = []\n      while (remaining > 0) {\n        const randInd = Math.floor(Math.random() * newData.lexemes.length)\n        const randLex = newData.lexemes[randInd]\n        list.push(attachAffix(randLex, der))\n        newData.lexemes.splice(randInd, 1)\n        remaining--\n      }\n      return list\n    }\n\n    // Derive from any base and any derivation\n    const deriveFromAny = () => {\n      const list = []\n      // Find only unique pairs of lexemes and affixes\n      const getUniqueItem = () => {\n        const randLex =\n          newData.lexemes[Math.floor(Math.random() * newData.lexemes.length)]\n        const randAff =\n          derivations[Math.floor(Math.random() * derivations.length)]\n        let newItem = attachAffix(randLex, randAff)\n        let isUnique = true\n        for (let i = 0; i < list.length; i++) {\n          if (JSON.stringify(newItem) === JSON.stringify(list[i])) {\n            isUnique = false\n            break\n          }\n        }\n        if (!isUnique) {\n          newItem = getUniqueItem()\n        }\n        return newItem\n      }\n      while (remaining > 0) {\n        list.push(getUniqueItem())\n        remaining--\n      }\n      return list\n    }\n\n    if (newData.type === 'single base') {\n      return { newWords: deriveFromSingleBase(), possible: possible }\n    } else if (newData.type === 'single derivation') {\n      return { newWords: deriveFromSingleDerivation(), possible: possible }\n    } else {\n      return { newWords: deriveFromAny(), possible: possible }\n    }\n  }\n}\n\nconst derivService = new DerivService()\n\nexport default derivService\n","import React, { useState } from 'react'\nimport { graphql, useStaticQuery } from 'gatsby'\n\nimport Tool from '../../components/tool'\n\nimport DerivForm from '../../pageComponents/deriv/derivForm'\nimport DerivResults from '../../pageComponents/deriv/derivResults'\nimport derivService from '../../services/derivService'\n\nimport styles from './deriv.module.sass'\n\nexport const PureDeriv = ({ data }) => {\n  const toolInfo = data?.site?.siteMetadata?.toolInfo?.deriv\n\n  // State\n\n  const [words, setWords] = useState(derivService.getData().words)\n  const [type, setType] = useState(derivService.getData().type)\n  const [lexemes, setLexemes] = useState(derivService.getData().lexemes)\n  const [derivations, setDerivations] = useState(\n    derivService.getData().derivations\n  )\n  const [results, setResults] = useState(derivService.getData().results)\n\n  // Functions\n\n  const onChange = e => {\n    const state = { words, type, lexemes, derivations, results }\n    if (e.target.tagName === 'BUTTON') {\n      e.preventDefault()\n      if (e.target.type === 'submit') {\n        // Derive the output\n        const response = derivService.derive(state)\n        state.results = response\n        setResults(response)\n        // Save the current state to storage\n        derivService.setStorage(state)\n      } else if (e.target.id === 'save') {\n        // Save the current state to storage and generate a file\n        derivService.save(state)\n      } else if (e.target.id.slice(3) === 'Add') {\n        const which = e.target.id.slice(0, 3)\n        // When the add button is clicked, add a blank row to state\n        const newData = derivService.add(state, which)\n        setLexemes(newData.lexemes)\n        setDerivations(newData.derivations)\n      } else if (e.target.id.slice(1, 2) === 'c') {\n        // When a row is cleared, delete teh corresponding row from state\n        const idNum = e.target.id.slice(2)\n        const which = e.target.id.slice(0, 1)\n        const newData = derivService.clear(state, idNum, which)\n        setLexemes(newData.lexemes)\n        setDerivations(newData.derivations)\n      }\n    } else if (e.target.type === 'file') {\n      e.preventDefault()\n      // Open a file and parse it to restore saved state\n      const file = e.target.files[0]\n      const updateState = response => {\n        if (response) {\n          // Only change state if the file was successfully opened\n          setWords(response.words)\n          setType(response.type)\n          setLexemes(response.lexemes)\n          setDerivations(response.derivations)\n          setResults(response.results)\n        }\n      }\n\n      derivService.open(file, updateState)\n    } else {\n      const idNum = e.target.id.slice(2)\n      const which = e.target.id.slice(0, 2)\n      const val = e.target.value\n      const name = e.target.name\n      if (\n        which === 'lw' ||\n        which === 'ld' ||\n        which === 'da' ||\n        which === 'dl' ||\n        which === 'dd'\n      ) {\n        const response = derivService.changeInput(state, idNum, which, val)\n        if (response) {\n          // Only change state if the input was successfully changed\n          setWords(response.words)\n          setType(response.type)\n          setLexemes(response.lexemes)\n          setDerivations(response.derivations)\n          setResults(response.results)\n        }\n      } else if (name === 'words') {\n        const response = derivService.wordNumChange(state, val)\n        if (response) {\n          // Only change state if the word number was successfully changed\n          setWords(response.words)\n          setType(response.type)\n          setLexemes(response.lexemes)\n          setDerivations(response.derivations)\n          setResults(response.results)\n        }\n      } else {\n        if (name === 'type') {\n          setType(val)\n        }\n      }\n    }\n  }\n\n  return (\n    <Tool toolInfo={toolInfo}>\n      <DerivForm\n        styles={styles}\n        data={{ words, type, lexemes, derivations }}\n        change={onChange}\n      />\n      <DerivResults styles={styles} results={results} />\n    </Tool>\n  )\n}\n\nconst Deriv = props => {\n  const data = useStaticQuery(graphql`\n    query DerivToolQuery {\n      site {\n        siteMetadata {\n          toolInfo {\n            deriv {\n              title\n              link\n              description\n            }\n          }\n        }\n      }\n    }\n  `)\n\n  return <PureDeriv {...props} data={data} />\n}\n\nexport default Deriv\n"],"sourceRoot":""}