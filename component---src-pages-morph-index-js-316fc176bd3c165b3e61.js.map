{"version":3,"sources":["webpack:///./src/pages/morph/morph.module.sass","webpack:///./src/components/notice/index.js","webpack:///./src/pageComponents/morph/morphForm.js","webpack:///./src/pageComponents/morph/morphResults.js","webpack:///./src/services/morphService.js","webpack:///./src/pages/morph/index.js","webpack:///./src/components/notice/notice.module.sass"],"names":["module","exports","Notice","children","className","styles","notice","MorphForm","data","change","morph","check","save","open","filePicker","React","createRef","join","name","section","classNames","categories","inputSection","sharedStyles","part","sectionTitle","container","id","categoriesInput","dataInput","value","onChange","aria-label","textAreaSpacer","rewriteRules","rewriteRulesInput","soundChanges","soundChangesInput","lexicon","lexiconInput","addedClasses","side","type","ver","onClick","htmlFor","outputFormat","checked","showChanges","showDiff","ruleReport","rewriteOutput","e","preventDefault","current","click","hidden","ref","MorphResults","stats","results","resultsArr","output","map","error","i","outText","format","result","trim","input","String","fromCharCode","classes","diff","different","changed","length","outputText","statsText","totalWords","unchangedWords","differentWords","total","same","countStats","unchanged","morphService","this","item","getData","bind","removeResults","setStorage","splitRewriteRules","rewriteCats","splitCategories","rewriteChanges","splitSoundChanges","rewriteLex","unrewriteLex","applyChanges","getResults","idDiff","dataProcessor","dataNoResults","JSON","parse","stringify","fileProcessor","file","callback","response","window","FileReader","openFile","endsWith","DataSchema","schema","Array","of","Boolean","content","words","toast","success","autoClose","bodyClassName","progressClassName","warn","console","errors","rules","splitRules","split","push","rewriteFrom","rewriteTo","cat","RegExp","replace","cats","assignments","rwSplit","thisCat","variable","newChange","prop","hasOwnProperty","changes","splitChanges","idChar","char","thisRule","changeFrom","changeTo","context","test","exec","exception","rwRule","changeFromArr","j","changeFromID","changeToArr","changeToID","contextArr","contextID","exceptionArr","exceptionID","lex","newLex","word","regRule","newResults","newWord","rpfc","rptc","rpe","reg","rwOutput","rwLexicon","undefined","newData","allErrors","concat","PureMorph","toolInfo","site","siteMetadata","useState","setCategories","setRewriteRules","setSoundChanges","setLexicon","setOutputFormat","setShowDiff","setShowChanges","setRuleReport","setRewriteOutput","setResults","val","target","state","files","Morph","props","useStaticQuery"],"mappings":"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","file":"component---src-pages-morph-index-js-316fc176bd3c165b3e61.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"section\":\"morph-module--section--1x2Hu\",\"container\":\"morph-module--container--516fo\",\"dataInput\":\"morph-module--data-input--GC2_A\",\"textAreaSpacer\":\"morph-module--text-area-spacer--9X8FX\",\"inputSection\":\"morph-module--input-section--5TGJN\",\"outText\":\"morph-module--out-text--zsbge\",\"different\":\"morph-module--different--2DmOi\",\"changed\":\"morph-module--changed--8IbT4\"};","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport styles from './notice.module.sass'\n\nconst Notice = ({ children }) => <p className={styles.notice}>{children}</p>\n\nNotice.propTypes = {\n  children: PropTypes.string\n}\n\nexport default Notice\n","import React from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Form from '../../components/form'\nimport Button from '../../components/button'\nimport Control from '../../components/control'\nimport ControlSide from '../../components/control/side'\nimport ControlPiece from '../../components/control/piece'\n\nimport sharedStyles from '../../components/form/sharedForm.module.sass'\n\nconst MorphForm = ({ styles, data, change, morph, check, save, open }) => {\n  const filePicker = React.createRef()\n\n  const join = data => data.join('\\n')\n\n  const invokeFilePicker = e => {\n    e.preventDefault()\n    filePicker.current.value = ''\n    filePicker.current.click()\n  }\n\n  return (\n    <Form name='morph-form'>\n      <div className={styles.section}>\n        <div\n          className={classNames(\n            styles.categories,\n            styles.inputSection,\n            sharedStyles.part\n          )}\n        >\n          <h5 className={sharedStyles.sectionTitle}>Categories</h5>\n          <div className={styles.container}>\n            <textarea\n              id='categories'\n              name='categories'\n              className={classNames(styles.categoriesInput, styles.dataInput)}\n              value={join(data.categories)}\n              onChange={change}\n              aria-label='Categories'\n            />\n            <div className={styles.textAreaSpacer}>\n              {join(data.categories)}&nbsp;\n            </div>\n          </div>\n        </div>\n        <div\n          className={classNames(\n            styles.rewriteRules,\n            styles.inputSection,\n            sharedStyles.part\n          )}\n        >\n          <h5 className={sharedStyles.sectionTitle}>Rewrite Rules</h5>\n          <div className={styles.container}>\n            <textarea\n              id='rewriteRules'\n              name='rewriteRules'\n              className={classNames(styles.rewriteRulesInput, styles.dataInput)}\n              value={join(data.rewriteRules)}\n              onChange={change}\n              aria-label='Rewrite rules'\n            />\n            <div className={styles.textAreaSpacer}>\n              {join(data.rewriteRules)}&nbsp;\n            </div>\n          </div>\n        </div>\n        <div\n          className={classNames(\n            styles.soundChanges,\n            styles.inputSection,\n            sharedStyles.part\n          )}\n        >\n          <h5 className={sharedStyles.sectionTitle}>Sound Changes</h5>\n          <div className={styles.container}>\n            <textarea\n              id='soundChanges'\n              name='soundChanges'\n              className={classNames(styles.soundChangesInput, styles.dataInput)}\n              value={join(data.soundChanges)}\n              onChange={change}\n              aria-label='Sound changes'\n            />\n            <div className={styles.textAreaSpacer}>\n              {join(data.soundChanges)}&nbsp;\n            </div>\n          </div>\n        </div>\n        <div\n          className={classNames(\n            styles.lexicon,\n            styles.inputSection,\n            sharedStyles.part\n          )}\n        >\n          <h5 className={sharedStyles.sectionTitle}>Lexicon</h5>\n          <div className={styles.container}>\n            <textarea\n              id='lexicon'\n              name='lexicon'\n              className={classNames(styles.lexiconInput, styles.dataInput)}\n              value={join(data.lexicon)}\n              onChange={change}\n              aria-label='Lexicon'\n            />\n            <div className={styles.textAreaSpacer}>\n              {join(data.lexicon)}&nbsp;\n            </div>\n          </div>\n        </div>\n      </div>\n      <Control addedClasses={sharedStyles.part}>\n        <ControlSide side='left'>\n          <ControlPiece>\n            <Button type='submit' ver='neutral' onClick={morph}>\n              Change\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <label htmlFor='outputFormat'>output format:</label>\n            <select\n              id='outputFormat'\n              name='outputFormat'\n              value={data.outputFormat}\n              onChange={change}\n            >\n              <option value='oo'>output</option>\n              <option value='io'>input &rarr; output</option>\n              <option value='oi'>output &larr; input</option>\n            </select>\n          </ControlPiece>\n          <ControlPiece>\n            <div>\n              <label>\n                <input\n                  type='checkbox'\n                  id='showChanges'\n                  name='options'\n                  value='showChanges'\n                  checked={data.showChanges}\n                  onChange={check}\n                />{' '}\n                italicize changes\n              </label>\n              <br />\n              <label>\n                <input\n                  type='checkbox'\n                  id='showDiff'\n                  name='options'\n                  value='showDiff'\n                  checked={data.showDiff}\n                  onChange={check}\n                />{' '}\n                bold differences\n              </label>\n            </div>\n          </ControlPiece>\n          <ControlPiece>\n            <div>\n              <label>\n                <input\n                  type='checkbox'\n                  id='ruleReport'\n                  name='options'\n                  value='ruleReport'\n                  checked={data.ruleReport}\n                  onChange={check}\n                />{' '}\n                report applied rules\n              </label>\n              <br />\n              <label>\n                <input\n                  type='checkbox'\n                  id='rewriteOutput'\n                  name='options'\n                  value='rewriteOutput'\n                  checked={data.rewriteOutput}\n                  onChange={check}\n                />{' '}\n                rewrite on output\n              </label>\n            </div>\n          </ControlPiece>\n        </ControlSide>\n        <ControlSide side='right'>\n          <ControlPiece>\n            <Button id='save' ver='success' onClick={save} type='button'>\n              Save\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <Button id='open' onClick={invokeFilePicker} type='button'>\n              Open\n            </Button>\n            <input\n              id='file'\n              name='file'\n              className={sharedStyles.hidden}\n              type='file'\n              ref={filePicker}\n              onChange={open}\n            />\n          </ControlPiece>\n        </ControlSide>\n      </Control>\n    </Form>\n  )\n}\n\nMorphForm.propTypes = {\n  styles: PropTypes.object,\n  data: PropTypes.shape({\n    categories: PropTypes.arrayOf(PropTypes.string).isRequired,\n    rewriteRules: PropTypes.arrayOf(PropTypes.string).isRequired,\n    soundChanges: PropTypes.arrayOf(PropTypes.string).isRequired,\n    lexicon: PropTypes.arrayOf(PropTypes.string).isRequired,\n    outputFormat: PropTypes.oneOf(['oo', 'io', 'oi']).isRequired,\n    showDiff: PropTypes.bool.isRequired,\n    showChanges: PropTypes.bool.isRequired,\n    ruleReport: PropTypes.bool.isRequired,\n    rewriteOutput: PropTypes.bool.isRequired\n  }).isRequired,\n  change: PropTypes.func.isRequired,\n  morph: PropTypes.func.isRequired,\n  check: PropTypes.func.isRequired,\n  save: PropTypes.func.isRequired,\n  open: PropTypes.func.isRequired\n}\n\nexport default MorphForm\n","import React from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Results from '../../components/results'\n\nimport sharedStyles from '../../components/results/sharedResults.module.sass'\n\nconst MorphResults = ({\n  styles,\n  outputFormat,\n  results,\n  showDiff,\n  showChanges\n}) => {\n  const resultsArr = results || []\n\n  const outputText = () => {\n    // If there were errors, print them\n    if (typeof resultsArr[0] === 'string') {\n      return resultsArr.map((error, i) => (\n        <p className={classNames(styles.outText, sharedStyles.error)} key={i}>\n          {error}\n        </p>\n      ))\n    }\n\n    // Format the results according to the selected option\n    const format = result => {\n      if (outputFormat === 'oo') {\n        return result.output.trim()\n      } else if (outputFormat === 'io') {\n        return `${result.input.trim()} ${String.fromCharCode(\n          8594\n        )} ${result.output.trim()}`\n      } else if (outputFormat === 'oi') {\n        return `${result.output.trim()} ${String.fromCharCode(\n          8592\n        )} ${result.input.trim()}`\n      }\n    }\n\n    // Assign the 'different' and 'changed' classes appropriately\n    const classes = result => {\n      if (showDiff && result.diff) {\n        if (showChanges && result.input !== result.output) {\n          return classNames(styles.outText, styles.different, styles.changed)\n        } else {\n          return classNames(styles.outText, styles.different)\n        }\n      } else {\n        if (showChanges && result.input !== result.output) {\n          return classNames(styles.outText, styles.changed)\n        } else {\n          return styles.outText\n        }\n      }\n    }\n\n    // Return the results text\n    return resultsArr.length > 0 ? (\n      resultsArr.map((result, i) => (\n        <p className={classes(result)} key={i}>\n          {format(result)}\n        </p>\n      ))\n    ) : (\n      <p className={styles.outText} />\n    )\n  }\n\n  const countStats = () => {\n    const totalWords = resultsArr.length\n    let unchangedWords = 0\n    let differentWords = 0\n    for (let i = 0; i < totalWords; i++) {\n      if (resultsArr[i].input === resultsArr[i].output) {\n        unchangedWords++\n      }\n\n      if (resultsArr[i].diff) {\n        differentWords++\n      }\n    }\n\n    const changedWords = totalWords - unchangedWords\n    const sameWords = totalWords - differentWords\n\n    return {\n      total: totalWords,\n      changed: changedWords,\n      unchangedWords: unchangedWords,\n      different: differentWords,\n      same: sameWords\n    }\n  }\n\n  const statsText = () => {\n    const stats = countStats()\n    return `${stats.changed} of ${stats.total} words changed (${stats.unchanged} unchanged); ${stats.different} of ${stats.total} words different from last time (${stats.same} the same)`\n  }\n\n  return (\n    <Results>\n      <div className={styles.output}>{outputText()}</div>\n      <div className={sharedStyles.stats}>\n        <p className={sharedStyles.statsText}>{statsText()}</p>\n      </div>\n    </Results>\n  )\n}\n\nMorphResults.propTypes = {\n  styles: PropTypes.object,\n  outputFormat: PropTypes.string.isRequired,\n  results: PropTypes.oneOfType([\n    PropTypes.arrayOf(\n      PropTypes.shape({\n        input: PropTypes.string.isRequired,\n        output: PropTypes.string.isRequired,\n        diff: PropTypes.bool.isRequired\n      })\n    ).isRequired,\n    PropTypes.arrayOf(PropTypes.string.isRequired).isRequired\n  ]),\n  showDiff: PropTypes.bool.isRequired,\n  showChanges: PropTypes.bool.isRequired\n}\n\nexport default MorphResults\n","import { toast } from 'react-toastify'\nimport schema from 'js-schema'\n\nimport dataProcessor from '../tools/dataProcessor'\nimport fileProcessor from '../tools/fileProcessor'\n\nclass MorphService {\n  constructor () {\n    this.item = 'morph'\n    this.getData = this.getData.bind(this)\n    this.removeResults = this.removeResults.bind(this)\n    this.setStorage = this.setStorage.bind(this)\n    this.save = this.save.bind(this)\n    this.open = this.open.bind(this)\n    this.splitRewriteRules = this.splitRewriteRules.bind(this)\n    this.rewriteCats = this.rewriteCats.bind(this)\n    this.splitCategories = this.splitCategories.bind(this)\n    this.rewriteChanges = this.rewriteChanges.bind(this)\n    this.splitSoundChanges = this.splitSoundChanges.bind(this)\n    this.rewriteLex = this.rewriteLex.bind(this)\n    this.unrewriteLex = this.unrewriteLex.bind(this)\n    this.applyChanges = this.applyChanges.bind(this)\n    this.getResults = this.getResults.bind(this)\n    this.idDiff = this.idDiff.bind(this)\n    this.morph = this.morph.bind(this)\n  }\n\n  // Get the data from storage or from the default data\n  getData () {\n    return dataProcessor.getData(this.item)\n  }\n\n  // Remove the results from the data\n  removeResults (data) {\n    const dataNoResults = JSON.parse(JSON.stringify(data))\n    delete dataNoResults.results\n    return dataNoResults\n  }\n\n  // Store the current data in storage\n  setStorage (data) {\n    dataProcessor.setStorage(this.removeResults(data), this.item)\n  }\n\n  // Save the current state to storage and generate a file\n  save (data) {\n    fileProcessor.save(this.removeResults(data), this.item)\n  }\n\n  // Open a file and parse it to restore a saved state\n  open (file, callback) {\n    let response\n\n    const processResults = result => {\n      // If correct filetype\n      if (file.name.endsWith('.lngm')) {\n        // Define correct file structure\n        const DataSchema = schema({\n          categories: Array.of(String),\n          rewriteRules: Array.of(String),\n          soundChanges: Array.of(String),\n          lexicon: Array.of(String),\n          outputFormat: ['oo', 'io', 'oi'],\n          showDiff: Boolean,\n          ruleReport: Boolean,\n          rewriteOutput: Boolean\n        })\n\n        const content = JSON.parse(result)\n\n        if (content.results) {\n          content.results.words = +content.results.words\n        }\n\n        if (DataSchema(content)) {\n          // If the file's content contains valid Data, load it\n          toast.success(`Data loaded from ${file.name}.`, {\n            autoClose: 5000,\n            className: 'toast-opened',\n            bodyClassName: 'toast-opened-body',\n            progressClassName: 'toast-opened-progress'\n          })\n\n          this.setStorage(content)\n\n          response = content\n        } else {\n          // If the file's content does not contain valid Data, show an error\n          toast.warn(`The content of ${file.name} is invalid.`, {\n            autoClose: 5000,\n            className: 'toast-unopened',\n            bodyClassName: 'toast-unopened-body',\n            progressClassName: 'toast-unopened-progress'\n          })\n\n          // eslint-disable-next-line\n          console.error(DataSchema.errors(content))\n\n          response = false\n        }\n      } else {\n        // If incorrect filetype\n        toast.warn('Wrong filetype selected.', {\n          autoClose: 5000,\n          className: 'toast-unopened',\n          bodyClassName: 'toast-unopened-body',\n          progressClassName: 'toast-unopened-progress'\n        })\n\n        response = false\n      }\n\n      callback(response)\n    }\n\n    if (window.FileReader) {\n      // If the browser has access to the File APIs, open the file\n      fileProcessor.openFile(file, processResults)\n    } else {\n      // If the browser can't access the File APIs, display a notification\n      toast.warn('Your browser is unable to open files.', {\n        autoClose: 5000,\n        className: 'toast-unopened',\n        bodyClassName: 'toast-unopened-body',\n        progressClassName: 'toast-unopened-progress'\n      })\n\n      response = false\n      callback(response)\n    }\n  }\n\n  // Split the rewrite rules into an array of objects\n  splitRewriteRules (rules) {\n    const splitRules = []\n    const errors = []\n\n    for (let i = 0; i < rules.length; i++) {\n      const split = rules[i].split('=')\n      if (split.length > 2) {\n        // If the string was split too many times, it had too many =\n        errors.push(`The rewrite rule ${rules[i]} has too many = signs.`)\n      } else if (split.length < 2) {\n        if (rules[i].length === 0) {\n          // If it was a blank line, ignore it\n          continue\n        } else {\n          // If the string wasn't split at all, it was missing a =\n          errors.push(`The rewrite rule ${rules[i]} is missing an = sign.`)\n        }\n      } else {\n        // Split the rewrite rule\n        splitRules.push({ rewriteFrom: split[0], rewriteTo: split[1] })\n      }\n    }\n\n    // If there are any errors that were logged, return the errors. Otherwise, return the split categories.\n    return errors.length ? errors : splitRules\n  }\n\n  // Apply the rewrite rules to the categories\n  rewriteCats (cat, rules) {\n    for (let i = 0; i < rules.length; i++) {\n      const rewriteFrom = new RegExp(rules[i].rewriteFrom, 'g')\n      cat[1] = cat[1].replace(rewriteFrom, rules[i].rewriteTo)\n    }\n    return cat\n  }\n\n  // Split the categories into an array of objects\n  splitCategories (cats, rules) {\n    const assignments = []\n    const errors = []\n\n    for (let i = 0; i < cats.length; i++) {\n      const split = cats[i].split('=')\n      if (split.length > 2) {\n        // If the string was split too many times, it had too many =\n        errors.push(`The category ${cats[i]} has too many = signs.`)\n      } else if (split.length < 2) {\n        if (cats[i].length === 0) {\n          // If it was a blank line, ignore it\n          continue\n        } else {\n          // If the string wasn't split at all, it was missing a =\n          errors.push(`The category ${cats[i]} is missing an = sign.`)\n        }\n      } else if (split[0].length > 1) {\n        // If the string to the left of the = is more than one character\n        errors.push(\n          `The category ${cats[i]} needs to be assigned to a single-character variable.`\n        )\n      } else {\n        const rwSplit = this.rewriteCats(split, rules)\n        // Split the variable from its assignments\n        assignments.push(rwSplit)\n      }\n    }\n\n    const splitCategories = []\n    for (let i = 0; i < assignments.length; i++) {\n      const thisCat = {}\n      thisCat.variable = assignments[i][0]\n      thisCat.categories = assignments[i][1].split('')\n      splitCategories.push(thisCat)\n    }\n\n    // If there are any errors that were logged, return the errors. Otherwise, return the split categories.\n    return errors.length ? errors : splitCategories\n  }\n\n  // Apply the rewrite rules to the sound change rules\n  rewriteChanges (change, rules) {\n    const newChange = JSON.parse(JSON.stringify(change))\n\n    for (const prop in newChange) {\n      if (newChange.hasOwnProperty(prop)) {\n        for (let i = 0; i < rules.length; i++) {\n          const rewriteFrom = new RegExp(rules[i].rewriteFrom, 'g')\n          newChange[prop] = newChange[prop].replace(\n            rewriteFrom,\n            rules[i].rewriteTo\n          )\n        }\n      }\n    }\n\n    return newChange\n  }\n\n  // Split the sound change rules into an array of objects\n  splitSoundChanges (cats, changes, rules) {\n    const splitChanges = []\n    const errors = []\n\n    const idChar = char => {\n      let cat = false\n      switch (char) {\n        case '_':\n          return 'target'\n        case '#':\n          return 'wordboundary'\n        case '[':\n          return 'brackopen'\n        case ']':\n          return 'brackclose'\n        case '(':\n          return 'parenopen'\n        case ')':\n          return 'parenclose'\n        default:\n          for (let i = 0; i < cats.length; i++) {\n            if (char === cats[i].variable) {\n              cat = true\n              break\n            }\n          }\n          return cat ? 'category' : 'literal'\n      }\n    }\n\n    for (let i = 0; i < changes.length; i++) {\n      const split = changes[i].split('/')\n      if (split.length > 4) {\n        // If hte string was split too many times, it had too many /\n        errors.push(`The sound change ${changes[i]} has too many / signs.`)\n      } else if (split.length < 2) {\n        if (changes[i].length === 0) {\n          // If it was a blank line, ignore it\n          continue\n        } else {\n          // If the string wasn't split at all, it was missing a /\n          errors.push(`The sound change ${changes[i]} is missing a / sign.`)\n        }\n      } else {\n        // Split the sound change rule into an object\n        const thisRule = {\n          changeFrom: split[0],\n          changeTo: split[1]\n        }\n        if (split[2]) {\n          thisRule.context = split[2]\n          if (!/_/.test(split[2])) {\n            errors.push(\n              `The context in the sound change ${changes[i]} is missing an _ sign.`\n            )\n          } else if (/_/.exec(split[2]).length > 2) {\n            errors.push(\n              `The context in the sound change ${changes[i]} has too many _ signs.`\n            )\n          }\n        }\n        if (split[3]) {\n          thisRule.exception = split[3]\n          if (!/_/.test(split[3])) {\n            errors.push(\n              `The exception in the sound change ${changes[i]} is missing an _ sign.`\n            )\n          } else if (/_/.exec(split[3]).length > 2) {\n            errors.push(\n              `The exception in the sound change ${changes[i]} has too many _ signs.`\n            )\n          }\n        }\n\n        const rwRule = this.rewriteChanges(thisRule, rules)\n\n        // ID all characters in each rule\n        const changeFromArr = []\n        for (let j = 0; j < rwRule.changeFrom.length; j++) {\n          changeFromArr.push(idChar(rwRule.changeFrom[j]))\n        }\n        rwRule.changeFromID = changeFromArr\n        const changeToArr = []\n        for (let j = 0; j < rwRule.changeTo.length; j++) {\n          changeToArr.push(idChar(rwRule.changeTo[j]))\n        }\n        rwRule.changeToID = changeToArr\n        const contextArr = []\n        if (rwRule.context) {\n          for (let j = 0; j < rwRule.context.length; j++) {\n            contextArr.push(idChar(rwRule.context[j]))\n          }\n          rwRule.contextID = contextArr\n        }\n        const exceptionArr = []\n        if (rwRule.exception) {\n          for (let j = 0; j < rwRule.exception.length; j++) {\n            exceptionArr.push(idChar(rwRule.exception[j]))\n          }\n          rwRule.exceptionID = exceptionArr\n        }\n\n        splitChanges.push(rwRule)\n      }\n    }\n\n    // If there are any errors that were logged, return the errors. Otherwise, return the split categories.\n    return errors.length ? errors : splitChanges\n  }\n\n  // Apply the rewrite rules to the lexicon\n  rewriteLex (lex, rules) {\n    const newLex = []\n\n    for (let i = 0; i < lex.length; i++) {\n      let word = lex[i]\n\n      for (let j = 0; j < rules.length; j++) {\n        const regRule = new RegExp(rules[j].rewriteFrom, 'g')\n        word = word.replace(regRule, rules[j].rewriteTo)\n      }\n\n      newLex.push(word)\n    }\n\n    return newLex\n  }\n\n  // Reverse-apply the rewrite rules to the output\n  unrewriteLex (results, rules) {\n    const newResults = JSON.parse(JSON.stringify(results))\n\n    for (let i = 0; i < newResults.length; i++) {\n      for (let j = 0; j < rules.length; j++) {\n        const regRule = new RegExp(rules[j].rewriteTo, 'g')\n        newResults[i].output = newResults[i].output.replace(\n          regRule,\n          rules[j].rewriteFrom\n        )\n      }\n    }\n\n    return newResults\n  }\n\n  // Apply the sound changes to a given word\n  applyChanges (cats, changes, word) {\n    let newWord = word\n\n    // For each rule\n    for (let i = 0; i < changes.length; i++) {\n      // Replace the # word boundary symbol with the regex \\b\n      const context = changes[i].context\n        ? changes[i].context.replace(/#/g, '\\\\b')\n        : undefined\n      const exception = changes[i].exception\n        ? changes[i].exception.replace(/#/g, '\\\\b')\n        : undefined\n\n      if (context) {\n        // This needs to be added\n      }\n\n      if (exception) {\n        // This needs to be added\n      }\n\n      let rpfc\n      let rptc\n      let rpe\n      let reg\n      if (changes[i].context) {\n        rpfc = changes[i].context.replace('_', changes[i].changeFrom)\n        rptc = changes[i].context.replace('_', changes[i].changeTo)\n        if (changes[i].exception) {\n          rpe = changes[i].exception.replace('_', changes[i].changeFrom)\n          // If there is an exception, replace in every context match except when it matches the exception\n          reg = new RegExp(`${rpe}|(${rpfc})`, 'g')\n          newWord = newWord.replace(reg, rptc)\n        } else {\n          // If there are no exceptions, replace in every context match\n          reg = new RegExp(rpfc, 'g')\n          newWord = newWord.replace(reg, rptc)\n        }\n      } else {\n        // If there is no context, replace in every match\n        reg = new RegExp(changes[i].changeFrom, 'g')\n        newWord = newWord.replace(reg, changes[i].changeTo)\n      }\n    }\n\n    return newWord\n  }\n\n  // Build the results object array\n  getResults (cats, rules, changes, lexicon, rwOutput) {\n    const rwLexicon = this.rewriteLex(lexicon, rules)\n    const results = []\n\n    for (let i = 0; i < lexicon.length; i++) {\n      results.push({\n        input: lexicon[i],\n        output: this.applyChanges(cats, changes, rwLexicon[i])\n      })\n    }\n\n    // If 'rewrite on output' is selected, rewrite the results. Otherwise, just return the results as-is.\n    return rwOutput ? this.unrewriteLex(results, rules) : results\n  }\n\n  idDiff (data, results) {\n    const newResults = JSON.parse(JSON.stringify(results))\n\n    if (\n      data.results !== undefined &&\n      data.results.length &&\n      typeof data.results[0] !== 'string'\n    ) {\n      for (let i = 0; i < newResults.length; i++) {\n        newResults[i].diff =\n          newResults[i].input !== data.results[i].input ||\n          newResults[i].output !== data.results[i].output\n      }\n    } else {\n      for (let i = 0; i < newResults.length; i++) {\n        newResults[i].diff = true\n      }\n    }\n\n    return newResults\n  }\n\n  morph (data) {\n    const newData = JSON.parse(JSON.stringify(data))\n\n    // Process the input\n    const rewriteRules = this.splitRewriteRules(newData.rewriteRules)\n    const categories = this.splitCategories(newData.categories, rewriteRules)\n    const soundChanges = this.splitSoundChanges(\n      categories,\n      newData.soundChanges,\n      rewriteRules\n    )\n\n    // Return the errors if there are any\n    let allErrors = []\n    if (typeof categories[0] === 'string') {\n      allErrors = allErrors.concat(categories)\n    }\n    if (typeof rewriteRules[0] === 'string') {\n      allErrors = allErrors.concat(rewriteRules)\n    }\n    if (typeof soundChanges[0] === 'string') {\n      allErrors = allErrors.concat(soundChanges)\n    }\n    if (allErrors.length) {\n      return allErrors\n    }\n\n    const results = this.getResults(\n      categories,\n      rewriteRules,\n      soundChanges,\n      newData.lexicon,\n      newData.rewriteOutput\n    )\n\n    return this.idDiff(newData, results)\n  }\n}\n\nconst morphService = new MorphService()\n\nexport default morphService\n","import React, { useState } from 'react'\nimport { graphql, useStaticQuery } from 'gatsby'\n\nimport Notice from '../../components/notice'\nimport Tool from '../../components/tool'\n\nimport MorphForm from '../../pageComponents/morph/morphForm'\nimport MorphResults from '../../pageComponents/morph/morphResults'\nimport morphService from '../../services/morphService'\n\nimport styles from './morph.module.sass'\n\nexport const PureMorph = ({ data }) => {\n  const toolInfo = data?.site?.siteMetadata?.toolInfo?.morph\n\n  // State\n\n  const [categories, setCategories] = useState(\n    morphService.getData().categories\n  )\n  const [rewriteRules, setRewriteRules] = useState(\n    morphService.getData().rewriteRules\n  )\n  const [soundChanges, setSoundChanges] = useState(\n    morphService.getData().soundChanges\n  )\n  const [lexicon, setLexicon] = useState(morphService.getData().lexicon)\n  const [outputFormat, setOutputFormat] = useState(\n    morphService.getData().outputFormat\n  )\n  const [showDiff, setShowDiff] = useState(morphService.getData().showDiff)\n  const [showChanges, setShowChanges] = useState(\n    morphService.getData().showChanges\n  )\n  const [ruleReport, setRuleReport] = useState(\n    morphService.getData().ruleReport\n  )\n  const [rewriteOutput, setRewriteOutput] = useState(\n    morphService.getData().rewriteOutput\n  )\n  const [results, setResults] = useState(morphService.getData().results)\n\n  // Functions\n\n  const onChange = e => {\n    // When an input field is changed, update state\n    const name = e.target.name\n    let val\n    if (e.target.type === 'textarea') {\n      // Split the textarea inputs by newlines\n      val = e.target.value.split('\\n')\n    } else {\n      // Just get the value of the input\n      val = e.target.value\n    }\n\n    switch (name) {\n      case 'categories':\n        setCategories(val)\n        break\n      case 'rewriteRules':\n        setRewriteRules(val)\n        break\n      case 'soundChanges':\n        setSoundChanges(val)\n        break\n      case 'lexicon':\n        setLexicon(val)\n        break\n      case 'outputFormat':\n        setOutputFormat(val)\n        break\n      default:\n    }\n  }\n\n  const onCheck = e => {\n    // When a checkbox option is changed, update state\n    const val = e.target.value\n    const checked = e.target.checked\n    switch (val) {\n      case 'showChanges':\n        setShowChanges(checked)\n        break\n      case 'showDiff':\n        setShowDiff(checked)\n        break\n      case 'ruleReport':\n        setRuleReport(checked)\n        break\n      case 'rewriteOutput':\n        setRewriteOutput(checked)\n        break\n      default:\n    }\n  }\n\n  const onMorph = e => {\n    e.preventDefault()\n    const state = {\n      categories,\n      rewriteRules,\n      soundChanges,\n      lexicon,\n      outputFormat,\n      showDiff,\n      showChanges,\n      ruleReport,\n      rewriteOutput,\n      results\n    }\n    // Generate the output\n    setResults(morphService.morph(state))\n    // Save the current state to storage\n    morphService.setStorage(state)\n  }\n\n  const onSave = e => {\n    e.preventDefault()\n    const state = {\n      categories,\n      rewriteRules,\n      soundChanges,\n      lexicon,\n      outputFormat,\n      showDiff,\n      showChanges,\n      ruleReport,\n      rewriteOutput,\n      results\n    }\n    // Save the current state to storage and generate a file\n    morphService.save(state)\n  }\n\n  const onOpen = e => {\n    e.preventDefault()\n    const file = e.target.files[0]\n    const updateState = response => {\n      // Only change state if the file was successfully opened\n      if (response) {\n        setCategories(response.categories)\n        setRewriteRules(response.rewriteRules)\n        setSoundChanges(response.soundChanges)\n        setLexicon(response.lexicon)\n        setOutputFormat(response.outputFormat)\n        setShowDiff(response.showDiff)\n        setShowChanges(response.showChanges)\n        setRuleReport(response.ruleReport)\n        setRewriteOutput(response.rewriteOutput)\n        setResults(response.results)\n      }\n    }\n\n    morphService.open(file, updateState)\n  }\n\n  return (\n    <Tool toolInfo={toolInfo}>\n      <Notice>This tool is still in development.</Notice>\n      <MorphForm\n        styles={styles}\n        data={{\n          categories,\n          rewriteRules,\n          soundChanges,\n          lexicon,\n          outputFormat,\n          showDiff,\n          showChanges,\n          ruleReport,\n          rewriteOutput\n        }}\n        change={onChange}\n        morph={onMorph}\n        check={onCheck}\n        save={onSave}\n        open={onOpen}\n      />\n      <MorphResults\n        styles={styles}\n        outputFormat={outputFormat}\n        results={results}\n        showDiff={showDiff}\n        showChanges={showChanges}\n      />\n    </Tool>\n  )\n}\n\nconst Morph = props => {\n  const data = useStaticQuery(graphql`\n    query MorphToolQuery {\n      site {\n        siteMetadata {\n          toolInfo {\n            morph {\n              title\n              link\n              description\n            }\n          }\n        }\n      }\n    }\n  `)\n\n  return <PureMorph {...props} data={data} />\n}\n\nexport default Morph\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"notice\":\"notice-module--notice--14xfk\"};"],"sourceRoot":""}