{"version":3,"sources":["webpack:///./src/pages/morph/morph.module.sass","webpack:///./src/components/notice/index.js","webpack:///./src/pageComponents/morph/morphForm.js","webpack:///./src/pageComponents/morph/morphResults.js","webpack:///./src/services/morphService.js","webpack:///./src/pages/morph/index.js","webpack:///./src/components/notice/notice.module.sass"],"names":["module","exports","Notice","children","className","styles","notice","MorphForm","data","change","morph","check","save","open","filePicker","React","createRef","join","name","section","classNames","categories","inputSection","sharedStyles","part","sectionTitle","container","id","categoriesInput","dataInput","value","onChange","aria-label","textAreaSpacer","rewriteRules","rewriteRulesInput","soundChanges","soundChangesInput","lexicon","lexiconInput","addedClasses","side","type","ver","onClick","htmlFor","outputFormat","checked","showChanges","showDiff","ruleReport","rewriteOutput","e","preventDefault","current","click","hidden","ref","MorphResults","stats","results","resultsArr","output","map","error","i","outText","key","classes","result","diff","input","different","changed","length","trim","String","fromCharCode","format","outputText","statsText","totalWords","unchangedWords","differentWords","total","same","countStats","unchanged","morphService","this","item","getData","bind","removeResults","setStorage","splitRewriteRules","rewriteCats","splitCategories","rewriteChanges","splitSoundChanges","rewriteLex","unrewriteLex","applyChanges","getResults","idDiff","dataProcessor","dataNoResults","JSON","parse","stringify","fileProcessor","file","callback","response","window","FileReader","openFile","endsWith","DataSchema","schema","Array","of","Boolean","content","words","toast","success","autoClose","bodyClassName","progressClassName","info","console","errors","rules","splitRules","split","push","rewriteFrom","rewriteTo","cat","RegExp","replace","cats","assignments","rwSplit","thisCat","variable","newChange","prop","hasOwnProperty","changes","splitChanges","idChar","char","thisRule","changeFrom","changeTo","context","test","exec","exception","rwRule","changeFromArr","j","changeFromID","changeToArr","changeToID","contextArr","contextID","exceptionArr","exceptionID","lex","newLex","word","regRule","newResults","newWord","rpfc","rptc","rpe","reg","rwOutput","rwLexicon","undefined","newData","allErrors","concat","PureMorph","toolInfo","site","siteMetadata","useState","setCategories","setRewriteRules","setSoundChanges","setLexicon","setOutputFormat","setShowDiff","setShowChanges","setRuleReport","setRewriteOutput","setResults","val","target","state","files","Morph","props","useStaticQuery"],"mappings":"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","file":"component---src-pages-morph-index-js-86f6d06181c02aeb3a58.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"section\":\"morph-module--section--1x2Hu\",\"container\":\"morph-module--container--516fo\",\"dataInput\":\"morph-module--data-input--GC2_A\",\"textAreaSpacer\":\"morph-module--text-area-spacer--9X8FX\",\"inputSection\":\"morph-module--input-section--5TGJN\",\"outText\":\"morph-module--out-text--zsbge\",\"different\":\"morph-module--different--2DmOi\",\"changed\":\"morph-module--changed--8IbT4\"};","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport styles from './notice.module.sass'\n\nconst Notice = ({ children }) => <p className={styles.notice}>{children}</p>\n\nNotice.propTypes = {\n  children: PropTypes.string\n}\n\nexport default Notice\n","import React from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Form from '../../components/form'\nimport Button from '../../components/button'\nimport Control from '../../components/control'\nimport ControlSide from '../../components/control/side'\nimport ControlPiece from '../../components/control/piece'\n\nimport sharedStyles from '../../components/form/sharedForm.module.sass'\n\nconst MorphForm = ({ styles, data, change, morph, check, save, open }) => {\n  const filePicker = React.createRef()\n\n  const join = data => data.join('\\n')\n\n  const invokeFilePicker = e => {\n    e.preventDefault()\n    filePicker.current.value = ''\n    filePicker.current.click()\n  }\n\n  return (\n    <Form name='morph-form'>\n      <div className={styles.section}>\n        <div\n          className={classNames(\n            styles.categories,\n            styles.inputSection,\n            sharedStyles.part\n          )}\n        >\n          <h5 className={sharedStyles.sectionTitle}>Categories</h5>\n          <div className={styles.container}>\n            <textarea\n              id='categories'\n              name='categories'\n              className={classNames(styles.categoriesInput, styles.dataInput)}\n              value={join(data.categories)}\n              onChange={change}\n              aria-label='Categories'\n            />\n            <div className={styles.textAreaSpacer}>\n              {join(data.categories)}&nbsp;\n            </div>\n          </div>\n        </div>\n        <div\n          className={classNames(\n            styles.rewriteRules,\n            styles.inputSection,\n            sharedStyles.part\n          )}\n        >\n          <h5 className={sharedStyles.sectionTitle}>Rewrite Rules</h5>\n          <div className={styles.container}>\n            <textarea\n              id='rewriteRules'\n              name='rewriteRules'\n              className={classNames(styles.rewriteRulesInput, styles.dataInput)}\n              value={join(data.rewriteRules)}\n              onChange={change}\n              aria-label='Rewrite rules'\n            />\n            <div className={styles.textAreaSpacer}>\n              {join(data.rewriteRules)}&nbsp;\n            </div>\n          </div>\n        </div>\n        <div\n          className={classNames(\n            styles.soundChanges,\n            styles.inputSection,\n            sharedStyles.part\n          )}\n        >\n          <h5 className={sharedStyles.sectionTitle}>Sound Changes</h5>\n          <div className={styles.container}>\n            <textarea\n              id='soundChanges'\n              name='soundChanges'\n              className={classNames(styles.soundChangesInput, styles.dataInput)}\n              value={join(data.soundChanges)}\n              onChange={change}\n              aria-label='Sound changes'\n            />\n            <div className={styles.textAreaSpacer}>\n              {join(data.soundChanges)}&nbsp;\n            </div>\n          </div>\n        </div>\n        <div\n          className={classNames(\n            styles.lexicon,\n            styles.inputSection,\n            sharedStyles.part\n          )}\n        >\n          <h5 className={sharedStyles.sectionTitle}>Lexicon</h5>\n          <div className={styles.container}>\n            <textarea\n              id='lexicon'\n              name='lexicon'\n              className={classNames(styles.lexiconInput, styles.dataInput)}\n              value={join(data.lexicon)}\n              onChange={change}\n              aria-label='Lexicon'\n            />\n            <div className={styles.textAreaSpacer}>\n              {join(data.lexicon)}&nbsp;\n            </div>\n          </div>\n        </div>\n      </div>\n      <Control addedClasses={sharedStyles.part}>\n        <ControlSide side='left'>\n          <ControlPiece>\n            <Button type='submit' ver='neutral' onClick={morph}>\n              Change\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <label htmlFor='outputFormat'>output format:</label>\n            <select\n              id='outputFormat'\n              name='outputFormat'\n              value={data.outputFormat}\n              onChange={change}\n            >\n              <option value='oo'>output</option>\n              <option value='io'>input &rarr; output</option>\n              <option value='oi'>output &larr; input</option>\n            </select>\n          </ControlPiece>\n          <ControlPiece>\n            <div>\n              <label>\n                <input\n                  type='checkbox'\n                  id='showChanges'\n                  name='options'\n                  value='showChanges'\n                  checked={data.showChanges}\n                  onChange={check}\n                />{' '}\n                italicize changes\n              </label>\n              <br />\n              <label>\n                <input\n                  type='checkbox'\n                  id='showDiff'\n                  name='options'\n                  value='showDiff'\n                  checked={data.showDiff}\n                  onChange={check}\n                />{' '}\n                bold differences\n              </label>\n            </div>\n          </ControlPiece>\n          <ControlPiece>\n            <div>\n              <label>\n                <input\n                  type='checkbox'\n                  id='ruleReport'\n                  name='options'\n                  value='ruleReport'\n                  checked={data.ruleReport}\n                  onChange={check}\n                />{' '}\n                report applied rules\n              </label>\n              <br />\n              <label>\n                <input\n                  type='checkbox'\n                  id='rewriteOutput'\n                  name='options'\n                  value='rewriteOutput'\n                  checked={data.rewriteOutput}\n                  onChange={check}\n                />{' '}\n                rewrite on output\n              </label>\n            </div>\n          </ControlPiece>\n        </ControlSide>\n        <ControlSide side='right'>\n          <ControlPiece>\n            <Button id='save' ver='success' onClick={save} type='button'>\n              Save\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <Button id='open' onClick={invokeFilePicker} type='button'>\n              Open\n            </Button>\n            <input\n              id='file'\n              name='file'\n              className={sharedStyles.hidden}\n              type='file'\n              ref={filePicker}\n              onChange={open}\n            />\n          </ControlPiece>\n        </ControlSide>\n      </Control>\n    </Form>\n  )\n}\n\nMorphForm.propTypes = {\n  styles: PropTypes.object,\n  data: PropTypes.shape({\n    categories: PropTypes.arrayOf(PropTypes.string).isRequired,\n    rewriteRules: PropTypes.arrayOf(PropTypes.string).isRequired,\n    soundChanges: PropTypes.arrayOf(PropTypes.string).isRequired,\n    lexicon: PropTypes.arrayOf(PropTypes.string).isRequired,\n    outputFormat: PropTypes.oneOf(['oo', 'io', 'oi']).isRequired,\n    showDiff: PropTypes.bool.isRequired,\n    showChanges: PropTypes.bool.isRequired,\n    ruleReport: PropTypes.bool.isRequired,\n    rewriteOutput: PropTypes.bool.isRequired\n  }).isRequired,\n  change: PropTypes.func.isRequired,\n  morph: PropTypes.func.isRequired,\n  check: PropTypes.func.isRequired,\n  save: PropTypes.func.isRequired,\n  open: PropTypes.func.isRequired\n}\n\nexport default MorphForm\n","import React from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Results from '../../components/results'\n\nimport sharedStyles from '../../components/results/sharedResults.module.sass'\n\nconst MorphResults = ({\n  styles,\n  outputFormat,\n  results,\n  showDiff,\n  showChanges\n}) => {\n  const resultsArr = results || []\n\n  const outputText = () => {\n    // If there were errors, print them\n    if (typeof resultsArr[0] === 'string') {\n      return resultsArr.map((error, i) => (\n        <p className={classNames(styles.outText, sharedStyles.error)} key={i}>\n          {error}\n        </p>\n      ))\n    }\n\n    // Format the results according to the selected option\n    const format = result => {\n      if (outputFormat === 'oo') {\n        return result.output.trim()\n      } else if (outputFormat === 'io') {\n        return `${result.input.trim()} ${String.fromCharCode(\n          8594\n        )} ${result.output.trim()}`\n      } else if (outputFormat === 'oi') {\n        return `${result.output.trim()} ${String.fromCharCode(\n          8592\n        )} ${result.input.trim()}`\n      }\n    }\n\n    // Assign the 'different' and 'changed' classes appropriately\n    const classes = result => {\n      if (showDiff && result.diff) {\n        if (showChanges && result.input !== result.output) {\n          return classNames(styles.outText, styles.different, styles.changed)\n        } else {\n          return classNames(styles.outText, styles.different)\n        }\n      } else {\n        if (showChanges && result.input !== result.output) {\n          return classNames(styles.outText, styles.changed)\n        } else {\n          return styles.outText\n        }\n      }\n    }\n\n    // Return the results text\n    return resultsArr.length > 0 ? (\n      resultsArr.map((result, i) => (\n        <p className={classes(result)} key={i}>\n          {format(result)}\n        </p>\n      ))\n    ) : (\n      <p className={styles.outText} />\n    )\n  }\n\n  const countStats = () => {\n    const totalWords = resultsArr.length\n    let unchangedWords = 0\n    let differentWords = 0\n    for (let i = 0; i < totalWords; i++) {\n      if (resultsArr[i].input === resultsArr[i].output) {\n        unchangedWords++\n      }\n\n      if (resultsArr[i].diff) {\n        differentWords++\n      }\n    }\n\n    const changedWords = totalWords - unchangedWords\n    const sameWords = totalWords - differentWords\n\n    return {\n      total: totalWords,\n      changed: changedWords,\n      unchangedWords: unchangedWords,\n      different: differentWords,\n      same: sameWords\n    }\n  }\n\n  const statsText = () => {\n    const stats = countStats()\n    return `${stats.changed} of ${stats.total} words changed (${stats.unchanged} unchanged); ${stats.different} of ${stats.total} words different from last time (${stats.same} the same)`\n  }\n\n  return (\n    <Results>\n      <div className={styles.output}>{outputText()}</div>\n      <div className={sharedStyles.stats}>\n        <p className={sharedStyles.statsText}>{statsText()}</p>\n      </div>\n    </Results>\n  )\n}\n\nMorphResults.propTypes = {\n  styles: PropTypes.object,\n  outputFormat: PropTypes.string.isRequired,\n  results: PropTypes.oneOfType([\n    PropTypes.arrayOf(\n      PropTypes.shape({\n        input: PropTypes.string.isRequired,\n        output: PropTypes.string.isRequired,\n        diff: PropTypes.bool.isRequired\n      })\n    ).isRequired,\n    PropTypes.arrayOf(PropTypes.string.isRequired).isRequired\n  ]),\n  showDiff: PropTypes.bool.isRequired,\n  showChanges: PropTypes.bool.isRequired\n}\n\nexport default MorphResults\n","import { toast } from 'react-toastify'\nimport schema from 'js-schema'\n\nimport dataProcessor from '../tools/dataProcessor'\nimport fileProcessor from '../tools/fileProcessor'\n\nclass MorphService {\n  constructor () {\n    this.item = 'morph'\n    this.getData = this.getData.bind(this)\n    this.removeResults = this.removeResults.bind(this)\n    this.setStorage = this.setStorage.bind(this)\n    this.save = this.save.bind(this)\n    this.open = this.open.bind(this)\n    this.splitRewriteRules = this.splitRewriteRules.bind(this)\n    this.rewriteCats = this.rewriteCats.bind(this)\n    this.splitCategories = this.splitCategories.bind(this)\n    this.rewriteChanges = this.rewriteChanges.bind(this)\n    this.splitSoundChanges = this.splitSoundChanges.bind(this)\n    this.rewriteLex = this.rewriteLex.bind(this)\n    this.unrewriteLex = this.unrewriteLex.bind(this)\n    this.applyChanges = this.applyChanges.bind(this)\n    this.getResults = this.getResults.bind(this)\n    this.idDiff = this.idDiff.bind(this)\n    this.morph = this.morph.bind(this)\n  }\n\n  // Get the data from storage or from the default data\n  getData () {\n    return dataProcessor.getData(this.item)\n  }\n\n  // Remove the results from the data\n  removeResults (data) {\n    const dataNoResults = JSON.parse(JSON.stringify(data))\n    delete dataNoResults.results\n    return dataNoResults\n  }\n\n  // Store the current data in storage\n  setStorage (data) {\n    dataProcessor.setStorage(this.removeResults(data), this.item)\n  }\n\n  // Save the current state to storage and generate a file\n  save (data) {\n    fileProcessor.save(this.removeResults(data), this.item)\n  }\n\n  // Open a file and parse it to restore a saved state\n  open (file, callback) {\n    let response\n\n    const processResults = result => {\n      // If correct filetype\n      if (file.name.endsWith('.lngm')) {\n        // Define correct file structure\n        const DataSchema = schema({\n          categories: Array.of(String),\n          rewriteRules: Array.of(String),\n          soundChanges: Array.of(String),\n          lexicon: Array.of(String),\n          outputFormat: ['oo', 'io', 'oi'],\n          showDiff: Boolean,\n          ruleReport: Boolean,\n          rewriteOutput: Boolean\n        })\n\n        const content = JSON.parse(result)\n\n        if (content.results) {\n          content.results.words = +content.results.words\n        }\n\n        if (DataSchema(content)) {\n          // If the file's content contains valid Data, load it\n          toast.success(`Data loaded from ${file.name}.`, {\n            autoClose: 5000,\n            className: 'toast-opened',\n            bodyClassName: 'toast-opened-body',\n            progressClassName: 'toast-opened-progress'\n          })\n\n          this.setStorage(content)\n\n          response = content\n        } else {\n          // If the file's content does not contain valid Data, show an error\n          toast.info(`The content of ${file.name} is invalid.`, {\n            autoClose: 5000,\n            className: 'toast-unopened',\n            bodyClassName: 'toast-unopened-body',\n            progressClassName: 'toast-unopened-progress'\n          })\n\n          // eslint-disable-next-line\n          console.error(DataSchema.errors(content))\n\n          response = false\n        }\n      } else {\n        // If incorrect filetype\n        toast.info('Wrong filetype selected.', {\n          autoClose: 5000,\n          className: 'toast-unopened',\n          bodyClassName: 'toast-unopened-body',\n          progressClassName: 'toast-unopened-progress'\n        })\n\n        response = false\n      }\n\n      callback(response)\n    }\n\n    if (window.FileReader) {\n      // If the browser has access to the File APIs, open the file\n      fileProcessor.openFile(file, processResults)\n    } else {\n      // If the browser can't access the File APIs, display a notification\n      toast.info('Your browser is unable to open files.', {\n        autoClose: 5000,\n        className: 'toast-unopened',\n        bodyClassName: 'toast-unopened-body',\n        progressClassName: 'toast-unopened-progress'\n      })\n\n      response = false\n      callback(response)\n    }\n  }\n\n  // Split the rewrite rules into an array of objects\n  splitRewriteRules (rules) {\n    const splitRules = []\n    const errors = []\n\n    for (let i = 0; i < rules.length; i++) {\n      const split = rules[i].split('=')\n      if (split.length > 2) {\n        // If the string was split too many times, it had too many =\n        errors.push(`The rewrite rule ${rules[i]} has too many = signs.`)\n      } else if (split.length < 2) {\n        if (rules[i].length === 0) {\n          // If it was a blank line, ignore it\n          continue\n        } else {\n          // If the string wasn't split at all, it was missing a =\n          errors.push(`The rewrite rule ${rules[i]} is missing an = sign.`)\n        }\n      } else {\n        // Split the rewrite rule\n        splitRules.push({ rewriteFrom: split[0], rewriteTo: split[1] })\n      }\n    }\n\n    // If there are any errors that were logged, return the errors. Otherwise, return the split categories.\n    return errors.length ? errors : splitRules\n  }\n\n  // Apply the rewrite rules to the categories\n  rewriteCats (cat, rules) {\n    for (let i = 0; i < rules.length; i++) {\n      const rewriteFrom = new RegExp(rules[i].rewriteFrom, 'g')\n      cat[1] = cat[1].replace(rewriteFrom, rules[i].rewriteTo)\n    }\n    return cat\n  }\n\n  // Split the categories into an array of objects\n  splitCategories (cats, rules) {\n    const assignments = []\n    const errors = []\n\n    for (let i = 0; i < cats.length; i++) {\n      const split = cats[i].split('=')\n      if (split.length > 2) {\n        // If the string was split too many times, it had too many =\n        errors.push(`The category ${cats[i]} has too many = signs.`)\n      } else if (split.length < 2) {\n        if (cats[i].length === 0) {\n          // If it was a blank line, ignore it\n          continue\n        } else {\n          // If the string wasn't split at all, it was missing a =\n          errors.push(`The category ${cats[i]} is missing an = sign.`)\n        }\n      } else if (split[0].length > 1) {\n        // If the string to the left of the = is more than one character\n        errors.push(\n          `The category ${cats[i]} needs to be assigned to a single-character variable.`\n        )\n      } else {\n        const rwSplit = this.rewriteCats(split, rules)\n        // Split the variable from its assignments\n        assignments.push(rwSplit)\n      }\n    }\n\n    const splitCategories = []\n    for (let i = 0; i < assignments.length; i++) {\n      const thisCat = {}\n      thisCat.variable = assignments[i][0]\n      thisCat.categories = assignments[i][1].split('')\n      splitCategories.push(thisCat)\n    }\n\n    // If there are any errors that were logged, return the errors. Otherwise, return the split categories.\n    return errors.length ? errors : splitCategories\n  }\n\n  // Apply the rewrite rules to the sound change rules\n  rewriteChanges (change, rules) {\n    const newChange = JSON.parse(JSON.stringify(change))\n\n    for (const prop in newChange) {\n      if (newChange.hasOwnProperty(prop)) {\n        for (let i = 0; i < rules.length; i++) {\n          const rewriteFrom = new RegExp(rules[i].rewriteFrom, 'g')\n          newChange[prop] = newChange[prop].replace(\n            rewriteFrom,\n            rules[i].rewriteTo\n          )\n        }\n      }\n    }\n\n    return newChange\n  }\n\n  // Split the sound change rules into an array of objects\n  splitSoundChanges (cats, changes, rules) {\n    const splitChanges = []\n    const errors = []\n\n    const idChar = char => {\n      let cat = false\n      switch (char) {\n        case '_':\n          return 'target'\n        case '#':\n          return 'wordboundary'\n        case '[':\n          return 'brackopen'\n        case ']':\n          return 'brackclose'\n        case '(':\n          return 'parenopen'\n        case ')':\n          return 'parenclose'\n        default:\n          for (let i = 0; i < cats.length; i++) {\n            if (char === cats[i].variable) {\n              cat = true\n              break\n            }\n          }\n          return cat ? 'category' : 'literal'\n      }\n    }\n\n    for (let i = 0; i < changes.length; i++) {\n      const split = changes[i].split('/')\n      if (split.length > 4) {\n        // If hte string was split too many times, it had too many /\n        errors.push(`The sound change ${changes[i]} has too many / signs.`)\n      } else if (split.length < 2) {\n        if (changes[i].length === 0) {\n          // If it was a blank line, ignore it\n          continue\n        } else {\n          // If the string wasn't split at all, it was missing a /\n          errors.push(`The sound change ${changes[i]} is missing a / sign.`)\n        }\n      } else {\n        // Split the sound change rule into an object\n        const thisRule = {\n          changeFrom: split[0],\n          changeTo: split[1]\n        }\n        if (split[2]) {\n          thisRule.context = split[2]\n          if (!/_/.test(split[2])) {\n            errors.push(\n              `The context in the sound change ${changes[i]} is missing an _ sign.`\n            )\n          } else if (/_/.exec(split[2]).length > 2) {\n            errors.push(\n              `The context in the sound change ${changes[i]} has too many _ signs.`\n            )\n          }\n        }\n        if (split[3]) {\n          thisRule.exception = split[3]\n          if (!/_/.test(split[3])) {\n            errors.push(\n              `The exception in the sound change ${changes[i]} is missing an _ sign.`\n            )\n          } else if (/_/.exec(split[3]).length > 2) {\n            errors.push(\n              `The exception in the sound change ${changes[i]} has too many _ signs.`\n            )\n          }\n        }\n\n        const rwRule = this.rewriteChanges(thisRule, rules)\n\n        // ID all characters in each rule\n        const changeFromArr = []\n        for (let j = 0; j < rwRule.changeFrom.length; j++) {\n          changeFromArr.push(idChar(rwRule.changeFrom[j]))\n        }\n        rwRule.changeFromID = changeFromArr\n        const changeToArr = []\n        for (let j = 0; j < rwRule.changeTo.length; j++) {\n          changeToArr.push(idChar(rwRule.changeTo[j]))\n        }\n        rwRule.changeToID = changeToArr\n        const contextArr = []\n        if (rwRule.context) {\n          for (let j = 0; j < rwRule.context.length; j++) {\n            contextArr.push(idChar(rwRule.context[j]))\n          }\n          rwRule.contextID = contextArr\n        }\n        const exceptionArr = []\n        if (rwRule.exception) {\n          for (let j = 0; j < rwRule.exception.length; j++) {\n            exceptionArr.push(idChar(rwRule.exception[j]))\n          }\n          rwRule.exceptionID = exceptionArr\n        }\n\n        splitChanges.push(rwRule)\n      }\n    }\n\n    // If there are any errors that were logged, return the errors. Otherwise, return the split categories.\n    return errors.length ? errors : splitChanges\n  }\n\n  // Apply the rewrite rules to the lexicon\n  rewriteLex (lex, rules) {\n    const newLex = []\n\n    for (let i = 0; i < lex.length; i++) {\n      let word = lex[i]\n\n      for (let j = 0; j < rules.length; j++) {\n        const regRule = new RegExp(rules[j].rewriteFrom, 'g')\n        word = word.replace(regRule, rules[j].rewriteTo)\n      }\n\n      newLex.push(word)\n    }\n\n    return newLex\n  }\n\n  // Reverse-apply the rewrite rules to the output\n  unrewriteLex (results, rules) {\n    const newResults = JSON.parse(JSON.stringify(results))\n\n    for (let i = 0; i < newResults.length; i++) {\n      for (let j = 0; j < rules.length; j++) {\n        const regRule = new RegExp(rules[j].rewriteTo, 'g')\n        newResults[i].output = newResults[i].output.replace(\n          regRule,\n          rules[j].rewriteFrom\n        )\n      }\n    }\n\n    return newResults\n  }\n\n  // Apply the sound changes to a given word\n  applyChanges (cats, changes, word) {\n    let newWord = word\n\n    // For each rule\n    for (let i = 0; i < changes.length; i++) {\n      // Replace the # word boundary symbol with the regex \\b\n      const context = changes[i].context\n        ? changes[i].context.replace(/#/g, '\\\\b')\n        : undefined\n      const exception = changes[i].exception\n        ? changes[i].exception.replace(/#/g, '\\\\b')\n        : undefined\n\n      if (context) {\n        // This needs to be added\n      }\n\n      if (exception) {\n        // This needs to be added\n      }\n\n      let rpfc\n      let rptc\n      let rpe\n      let reg\n      if (changes[i].context) {\n        rpfc = changes[i].context.replace('_', changes[i].changeFrom)\n        rptc = changes[i].context.replace('_', changes[i].changeTo)\n        if (changes[i].exception) {\n          rpe = changes[i].exception.replace('_', changes[i].changeFrom)\n          // If there is an exception, replace in every context match except when it matches the exception\n          reg = new RegExp(`${rpe}|(${rpfc})`, 'g')\n          newWord = newWord.replace(reg, rptc)\n        } else {\n          // If there are no exceptions, replace in every context match\n          reg = new RegExp(rpfc, 'g')\n          newWord = newWord.replace(reg, rptc)\n        }\n      } else {\n        // If there is no context, replace in every match\n        reg = new RegExp(changes[i].changeFrom, 'g')\n        newWord = newWord.replace(reg, changes[i].changeTo)\n      }\n    }\n\n    return newWord\n  }\n\n  // Build the results object array\n  getResults (cats, rules, changes, lexicon, rwOutput) {\n    const rwLexicon = this.rewriteLex(lexicon, rules)\n    const results = []\n\n    for (let i = 0; i < lexicon.length; i++) {\n      results.push({\n        input: lexicon[i],\n        output: this.applyChanges(cats, changes, rwLexicon[i])\n      })\n    }\n\n    // If 'rewrite on output' is selected, rewrite the results. Otherwise, just return the results as-is.\n    return rwOutput ? this.unrewriteLex(results, rules) : results\n  }\n\n  idDiff (data, results) {\n    const newResults = JSON.parse(JSON.stringify(results))\n\n    if (\n      data.results !== undefined &&\n      data.results.length &&\n      typeof data.results[0] !== 'string'\n    ) {\n      for (let i = 0; i < newResults.length; i++) {\n        newResults[i].diff =\n          newResults[i].input !== data.results[i].input ||\n          newResults[i].output !== data.results[i].output\n      }\n    } else {\n      for (let i = 0; i < newResults.length; i++) {\n        newResults[i].diff = true\n      }\n    }\n\n    return newResults\n  }\n\n  morph (data) {\n    const newData = JSON.parse(JSON.stringify(data))\n\n    // Process the input\n    const rewriteRules = this.splitRewriteRules(newData.rewriteRules)\n    const categories = this.splitCategories(newData.categories, rewriteRules)\n    const soundChanges = this.splitSoundChanges(\n      categories,\n      newData.soundChanges,\n      rewriteRules\n    )\n\n    // Return the errors if there are any\n    let allErrors = []\n    if (typeof categories[0] === 'string') {\n      allErrors = allErrors.concat(categories)\n    }\n    if (typeof rewriteRules[0] === 'string') {\n      allErrors = allErrors.concat(rewriteRules)\n    }\n    if (typeof soundChanges[0] === 'string') {\n      allErrors = allErrors.concat(soundChanges)\n    }\n    if (allErrors.length) {\n      return allErrors\n    }\n\n    const results = this.getResults(\n      categories,\n      rewriteRules,\n      soundChanges,\n      newData.lexicon,\n      newData.rewriteOutput\n    )\n\n    return this.idDiff(newData, results)\n  }\n}\n\nconst morphService = new MorphService()\n\nexport default morphService\n","import React, { useState } from 'react'\nimport { graphql, useStaticQuery } from 'gatsby'\n\nimport Notice from '../../components/notice'\nimport Tool from '../../components/tool'\n\nimport MorphForm from '../../pageComponents/morph/morphForm'\nimport MorphResults from '../../pageComponents/morph/morphResults'\nimport morphService from '../../services/morphService'\n\nimport styles from './morph.module.sass'\n\nexport const PureMorph = ({ data }) => {\n  const toolInfo = data?.site?.siteMetadata?.toolInfo?.morph\n\n  // State\n\n  const [categories, setCategories] = useState(\n    morphService.getData().categories\n  )\n  const [rewriteRules, setRewriteRules] = useState(\n    morphService.getData().rewriteRules\n  )\n  const [soundChanges, setSoundChanges] = useState(\n    morphService.getData().soundChanges\n  )\n  const [lexicon, setLexicon] = useState(morphService.getData().lexicon)\n  const [outputFormat, setOutputFormat] = useState(\n    morphService.getData().outputFormat\n  )\n  const [showDiff, setShowDiff] = useState(morphService.getData().showDiff)\n  const [showChanges, setShowChanges] = useState(\n    morphService.getData().showChanges\n  )\n  const [ruleReport, setRuleReport] = useState(\n    morphService.getData().ruleReport\n  )\n  const [rewriteOutput, setRewriteOutput] = useState(\n    morphService.getData().rewriteOutput\n  )\n  const [results, setResults] = useState(morphService.getData().results)\n\n  // Functions\n\n  const onChange = e => {\n    // When an input field is changed, update state\n    const name = e.target.name\n    let val\n    if (e.target.type === 'textarea') {\n      // Split the textarea inputs by newlines\n      val = e.target.value.split('\\n')\n    } else {\n      // Just get the value of the input\n      val = e.target.value\n    }\n\n    switch (name) {\n      case 'categories':\n        setCategories(val)\n        break\n      case 'rewriteRules':\n        setRewriteRules(val)\n        break\n      case 'soundChanges':\n        setSoundChanges(val)\n        break\n      case 'lexicon':\n        setLexicon(val)\n        break\n      case 'outputFormat':\n        setOutputFormat(val)\n        break\n      default:\n    }\n  }\n\n  const onCheck = e => {\n    // When a checkbox option is changed, update state\n    const val = e.target.value\n    const checked = e.target.checked\n    switch (val) {\n      case 'showChanges':\n        setShowChanges(checked)\n        break\n      case 'showDiff':\n        setShowDiff(checked)\n        break\n      case 'ruleReport':\n        setRuleReport(checked)\n        break\n      case 'rewriteOutput':\n        setRewriteOutput(checked)\n        break\n      default:\n    }\n  }\n\n  const onMorph = e => {\n    e.preventDefault()\n    const state = {\n      categories,\n      rewriteRules,\n      soundChanges,\n      lexicon,\n      outputFormat,\n      showDiff,\n      showChanges,\n      ruleReport,\n      rewriteOutput,\n      results\n    }\n    // Generate the output\n    setResults(morphService.morph(state))\n    // Save the current state to storage\n    morphService.setStorage(state)\n  }\n\n  const onSave = e => {\n    e.preventDefault()\n    const state = {\n      categories,\n      rewriteRules,\n      soundChanges,\n      lexicon,\n      outputFormat,\n      showDiff,\n      showChanges,\n      ruleReport,\n      rewriteOutput,\n      results\n    }\n    // Save the current state to storage and generate a file\n    morphService.save(state)\n  }\n\n  const onOpen = e => {\n    e.preventDefault()\n    const file = e.target.files[0]\n    const updateState = response => {\n      // Only change state if the file was successfully opened\n      if (response) {\n        setCategories(response.categories)\n        setRewriteRules(response.rewriteRules)\n        setSoundChanges(response.soundChanges)\n        setLexicon(response.lexicon)\n        setOutputFormat(response.outputFormat)\n        setShowDiff(response.showDiff)\n        setShowChanges(response.showChanges)\n        setRuleReport(response.ruleReport)\n        setRewriteOutput(response.rewriteOutput)\n        setResults(response.results)\n      }\n    }\n\n    morphService.open(file, updateState)\n  }\n\n  return (\n    <Tool toolInfo={toolInfo}>\n      <Notice>This tool is still in development.</Notice>\n      <MorphForm\n        styles={styles}\n        data={{\n          categories,\n          rewriteRules,\n          soundChanges,\n          lexicon,\n          outputFormat,\n          showDiff,\n          showChanges,\n          ruleReport,\n          rewriteOutput\n        }}\n        change={onChange}\n        morph={onMorph}\n        check={onCheck}\n        save={onSave}\n        open={onOpen}\n      />\n      <MorphResults\n        styles={styles}\n        outputFormat={outputFormat}\n        results={results}\n        showDiff={showDiff}\n        showChanges={showChanges}\n      />\n    </Tool>\n  )\n}\n\nconst Morph = props => {\n  const data = useStaticQuery(graphql`\n    query MorphToolQuery {\n      site {\n        siteMetadata {\n          toolInfo {\n            morph {\n              title\n              link\n              description\n            }\n          }\n        }\n      }\n    }\n  `)\n\n  return <PureMorph {...props} data={data} />\n}\n\nexport default Morph\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"notice\":\"notice-module--notice--14xfk\"};"],"sourceRoot":""}