{"version":3,"sources":["webpack:///./src/pages/gen/gen.module.sass","webpack:///./src/pageComponents/gen/genForm.js","webpack:///./src/pageComponents/gen/genResults.js","webpack:///./src/services/genService.js","webpack:///./src/pages/gen/index.js"],"names":["module","exports","GenForm","styles","data","change","filePicker","React","createRef","selectOptions","vars","map","variab","index","key","value","subpatternRows","subpatterns","subpattern","className","subpsRow","id","name","selected","onChange","select","aria-label","type","subpatternInput","clearButton","onClick","ver","small","classNames","sharedStyles","part","sectionTitle","length","addingRow","addButton","pattern","patternInput","addedClasses","side","htmlFor","min","max","wordsInput","words","checked","newline","filterdupes","e","preventDefault","current","click","hidden","ref","GenResults","filterResults","joinedResults","filterDupes","status","results","stats","toLocaleString","maxWords","filteredWords","filtered","remainingWords","remaining","output","includes","error","Array","from","Set","prototype","join","call","trim","outText","statsText","genService","this","item","getData","bind","setStorage","save","open","changeSelect","changeSubpattern","clear","add","changePattern","wordNumChange","changeNewline","changeDupes","checkErrors","generate","build","dataProcessor","fileProcessor","file","callback","response","window","FileReader","openFile","result","endsWith","filetype","SubpatternSchema","schema","String","DataSchema","of","Number","Boolean","content","JSON","parse","parseInt","toast","success","autoClose","bodyClassName","progressClassName","info","console","errors","val","newData","stringify","splice","toUse","i","used","j","push","idDeps","deps","checkCirc","refed","sp","getSp","circ","duplicates","dupes","defed","undefed","undefSet","undefs","chooseRand","Math","floor","random","resolveVar","letter","getSubpattern","selection","resolveOpt","option","letters","test","split","pattArr","word","patt","count","optCount","addCount","multCount","k","PureGen","toolInfo","site","siteMetadata","gen","useState","setSubpatterns","setPattern","setWords","setNewline","setFilterdupes","setStatus","setResults","setStats","newdata","target","tagName","slice","files","which","Gen","props","useStaticQuery"],"mappings":"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","file":"component---src-pages-gen-index-js-361e7616e699f8f5a9fc.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"duplicate\":\"gen-module--duplicate--36Pho\",\"subpsRow\":\"gen-module--subps-row--wHFCN\",\"addingRow\":\"gen-module--adding-row--1HMYb\",\"patternInput\":\"gen-module--pattern-input--Cpg1o\",\"subpatternInput\":\"gen-module--subpattern-input--1r5rf\",\"wordsInput\":\"gen-module--words-input--g2ABN\",\"outText\":\"gen-module--out-text--DeUHT\"};","import React from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Form from '../../components/form'\nimport Button from '../../components/button'\nimport Control from '../../components/control'\nimport ControlSide from '../../components/control/side'\nimport ControlPiece from '../../components/control/piece'\n\nimport sharedStyles from '../../components/form/sharedForm.module.sass'\n\nimport { vars } from '../../data/gen'\n\nconst GenForm = ({ styles, data, change }) => {\n  const filePicker = React.createRef()\n\n  const selectOptions = vars.map((variab, index) => (\n    <option key={index} value={variab}>\n      {variab}\n    </option>\n  ))\n\n  const subpatternRows = data.subpatterns.map((subpattern, index) => (\n    <div key={index} className={styles.subpsRow}>\n      <select\n        id={`v${index}`}\n        name={`v${index}`}\n        value={subpattern.selected}\n        onChange={change}\n        className={styles.select}\n        aria-label={`Variable name for subpattern ${index}`}\n      >\n        {selectOptions}\n      </select>\n      <input\n        type='text'\n        id={`p${index}`}\n        name={`p${index}`}\n        className={styles.subpatternInput}\n        value={subpattern.subpattern}\n        onChange={change}\n        aria-label={`Subpattern ${index}`}\n      />\n      <div className={styles.clearButton}>\n        <Button\n          id={`c${index}`}\n          onClick={change}\n          ver='danger'\n          small\n          type='button'\n          aria-label={`Delete subpattern ${index}`}\n        >\n          Delete\n        </Button>\n      </div>\n    </div>\n  ))\n\n  const addButton = () => {\n    if (data.subpatterns.length < vars.length) {\n      return (\n        <div className={styles.addingRow}>\n          <Button\n            onClick={change}\n            id='add'\n            ver='success'\n            small\n            type='button'\n            aria-label='Add a new subpattern'\n          >\n            Add\n          </Button>\n        </div>\n      )\n    }\n  }\n\n  const invokeFilePicker = e => {\n    e.preventDefault()\n    filePicker.current.value = ''\n    filePicker.current.click()\n  }\n\n  return (\n    <Form name='gen-form'>\n      <div className={classNames(styles.subpatterns, sharedStyles.part)}>\n        <h5 className={sharedStyles.sectionTitle}>Subpatterns</h5>\n        {subpatternRows}\n        {addButton()}\n      </div>\n      <div className={classNames(styles.pattern, sharedStyles.part)}>\n        <h5 className={sharedStyles.sectionTitle}>Pattern</h5>\n        <input\n          type='text'\n          id='pattern'\n          name='pattern'\n          className={styles.patternInput}\n          value={data.pattern}\n          onChange={change}\n          aria-label='Pattern'\n        />\n      </div>\n      <Control addedClasses={sharedStyles.part}>\n        <ControlSide side='left'>\n          <ControlPiece>\n            <Button id='generate' onClick={change} type='submit' ver='neutral'>\n              Generate\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <label htmlFor='words'>words:</label>\n            <input\n              type='number'\n              id='words'\n              name='words'\n              min='1'\n              max='9999'\n              className={styles.wordsInput}\n              value={data.words}\n              onChange={change}\n              aria-label='Number of words to generate'\n            />\n          </ControlPiece>\n          <ControlPiece>\n            <label>\n              <input\n                type='checkbox'\n                id='newline'\n                name='options'\n                value='newline'\n                checked={data.newline}\n                onChange={change}\n              />{' '}\n              new line each\n            </label>\n          </ControlPiece>\n          <ControlPiece>\n            <label>\n              <input\n                type='checkbox'\n                id='filterdupes'\n                name='options'\n                value='filterdupes'\n                checked={data.filterdupes}\n                onChange={change}\n              />{' '}\n              filter duplicates\n            </label>\n          </ControlPiece>\n        </ControlSide>\n        <ControlSide side='right'>\n          <ControlPiece>\n            <Button id='save' ver='success' onClick={change} type='button'>\n              Save\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <Button id='open' onClick={invokeFilePicker} type='button'>\n              Open\n            </Button>\n            <input\n              id='file'\n              name='file'\n              className={sharedStyles.hidden}\n              type='file'\n              ref={filePicker}\n              onChange={change}\n            />\n          </ControlPiece>\n        </ControlSide>\n      </Control>\n    </Form>\n  )\n}\n\nGenForm.propTypes = {\n  styles: PropTypes.object,\n  data: PropTypes.shape({\n    subpatterns: PropTypes.arrayOf(\n      PropTypes.shape({\n        selected: PropTypes.string.isRequired,\n        subpattern: PropTypes.string.isRequired\n      })\n    ).isRequired,\n    pattern: PropTypes.string.isRequired,\n    words: PropTypes.number.isRequired,\n    newline: PropTypes.bool.isRequired,\n    filterdupes: PropTypes.bool.isRequired\n  }).isRequired,\n  change: PropTypes.func.isRequired\n}\n\nexport default GenForm\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport Results from '../../components/results'\n\nimport sharedStyles from '../../components/results/sharedResults.module.sass'\n\nconst GenResults = ({\n  styles,\n  newline,\n  filterDupes,\n  status,\n  results,\n  stats\n}) => {\n  const words = stats.words.toLocaleString()\n  const maxWords = stats.maxWords.toLocaleString()\n  const filteredWords = stats.filtered.toLocaleString()\n  const remainingWords = stats.remaining.toLocaleString()\n\n  const outputText = () => {\n    const filterResults = filterDupes ? Array.from(new Set(results)) : results\n    const joinedResults = Array.prototype.join\n      .call(filterResults, `${newline ? '\\n' : ' '}`)\n      .trim()\n\n    return <p className={styles.outText}>{joinedResults}</p>\n  }\n\n  const errorText = () => {\n    if (status.includes('ok')) {\n      return null\n    } else {\n      return status.map((error, index) => (\n        <p key={index} className={sharedStyles.error}>\n          {error}\n        </p>\n      ))\n    }\n  }\n\n  const statsText = () => {\n    if (filterDupes) {\n      return `words: ${remainingWords} (${filteredWords} filtered out); maximum different words: ${maxWords}`\n    } else {\n      return `words: ${words}; maximum different words: ${maxWords}`\n    }\n  }\n\n  return (\n    <Results>\n      <div className={styles.output}>\n        {errorText()}\n        {outputText()}\n      </div>\n      <div className={sharedStyles.stats}>\n        <p className={sharedStyles.statsText}>{statsText()}</p>\n      </div>\n    </Results>\n  )\n}\n\nGenResults.propTypes = {\n  styles: PropTypes.object,\n  newline: PropTypes.bool.isRequired,\n  filterDupes: PropTypes.bool.isRequired,\n  status: PropTypes.arrayOf(PropTypes.string).isRequired,\n  results: PropTypes.arrayOf(PropTypes.string).isRequired,\n  stats: PropTypes.shape({\n    words: PropTypes.number.isRequired,\n    maxWords: PropTypes.number.isRequired,\n    filtered: PropTypes.number.isRequired,\n    remaining: PropTypes.number.isRequired\n  }).isRequired\n}\n\nexport default GenResults\n","import { toast } from 'react-toastify'\nimport schema from 'js-schema'\n\nimport dataProcessor from '../tools/dataProcessor'\nimport fileProcessor from '../tools/fileProcessor'\n\nimport { vars } from '../data/gen'\n\nclass GenService {\n  constructor () {\n    this.item = 'gen'\n    this.getData = this.getData.bind(this)\n    this.setStorage = this.setStorage.bind(this)\n    this.save = this.save.bind(this)\n    this.open = this.open.bind(this)\n    this.changeSelect = this.changeSelect.bind(this)\n    this.changeSubpattern = this.changeSubpattern.bind(this)\n    this.clear = this.clear.bind(this)\n    this.add = this.add.bind(this)\n    this.changePattern = this.changePattern.bind(this)\n    this.wordNumChange = this.wordNumChange.bind(this)\n    this.changeNewline = this.changeNewline.bind(this)\n    this.changeDupes = this.changeDupes.bind(this)\n    this.checkErrors = this.checkErrors.bind(this)\n    this.generate = this.generate.bind(this)\n    this.build = this.build.bind(this)\n  }\n\n  // Get the data from storage or from the default data\n  getData () {\n    return dataProcessor.getData(this.item)\n  }\n\n  // Store the current data in storage\n  setStorage (data) {\n    dataProcessor.setStorage(data, this.item)\n  }\n\n  // Save the current state to storage and generate a file\n  save (data) {\n    fileProcessor.save(data, this.item)\n  }\n\n  // Open a file and parse it to restore a saved state\n  open (file, callback) {\n    let response\n\n    const processResults = result => {\n      // If correct filetype\n      if (file.name.endsWith(fileProcessor.filetype(this.item))) {\n        // Define correct file structure\n        const SubpatternSchema = schema({\n          selected: /[A-Z]/,\n          subpattern: String\n        })\n\n        const DataSchema = schema({\n          subpatterns: Array.of(1, 24, SubpatternSchema),\n          pattern: String,\n          words: Number.min(1).max(9999),\n          newline: Boolean,\n          filterdupes: Boolean\n        })\n\n        const content = JSON.parse(result)\n\n        content.words = parseInt(content.words, 10)\n\n        if (DataSchema(content)) {\n          // If the file's content contains valid Data, load it\n          toast.success(`Data loaded from ${file.name}.`, {\n            autoClose: 5000,\n            className: 'toast-opened',\n            bodyClassName: 'toast-opened-body',\n            progressClassName: 'toast-opened-progress'\n          })\n\n          this.setStorage(content)\n\n          response = content\n        } else {\n          // If the file's content does not contain valid Data, show an error\n          toast.info(`The content of ${file.name} is invalid.`, {\n            autoClose: 5000,\n            className: 'toast-unopened',\n            bodyClassName: 'toast-unopened-body',\n            progressClassName: 'toast-unopened-progress'\n          })\n\n          // eslint-disable-next-line\n          console.error(DataSchema.errors(content))\n\n          response = false\n        }\n      } else {\n        // If incorrect filetype\n        toast.info('Wrong filetype selected.', {\n          autoClose: 5000,\n          className: 'toast-unopened',\n          bodyClassName: 'toast-unopened-body',\n          progressClassName: 'toast-unopened-progress'\n        })\n\n        response = false\n      }\n\n      callback(response)\n    }\n\n    if (window.FileReader) {\n      // If the browser has access to the File APIs, open the file\n      fileProcessor.openFile(file, processResults)\n    } else {\n      // If the browser can't access the File APIs, display a notification\n      toast.info('Your browser is unable to open files.', {\n        autoClose: 5000,\n        className: 'toast-unopened',\n        bodyClassName: 'toast-unopened-body',\n        progressClassName: 'toast-unopened-progress'\n      })\n\n      response = false\n      callback(response)\n    }\n  }\n\n  // When a Subpattern variable is changed, create a new version of state\n  changeSelect (id, val, data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    newData.subpatterns[id].selected = val\n    return newData\n  }\n\n  // When a Subpattern is changed, create a new version of state\n  changeSubpattern (id, val, data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    newData.subpatterns[id].subpattern = val\n    return newData\n  }\n\n  // When a Subpattern is cleared, create a new version of state\n  clear (id, data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    newData.subpatterns.splice(id, 1)\n    return newData\n  }\n\n  // When a Subpattern is added, create a new version of state\n  add (data) {\n    let toUse = ''\n    const newData = JSON.parse(JSON.stringify(data))\n\n    // Identify the first unused Subpattern variable and select it\n    for (let i = 0; i < vars.length; i++) {\n      let used = false\n      for (let j = 0; j < newData.subpatterns.length; j++) {\n        if (newData.subpatterns[j].selected === vars[i]) {\n          used = true\n          break\n        } else {\n          continue\n        }\n      }\n      if (!used) {\n        toUse = vars[i]\n        break\n      } else {\n        continue\n      }\n    }\n\n    if (newData.subpatterns.length < vars.length) {\n      newData.subpatterns.push({ selected: toUse, subpattern: '' })\n    }\n\n    return newData\n  }\n\n  // When the pattern is changed, create a new version of state\n  changePattern (val, data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    newData.pattern = val\n    return newData\n  }\n\n  // When the number of desired words is changed, create a new version of state\n  wordNumChange (val, data) {\n    // Limit number entry to between 1 and 9999\n    if (val < 1) {\n      val = 1\n    } else if (val > 9999) {\n      val = 9999\n    }\n\n    // Only change state if the number is between 1 and 9999\n    if (val > 0 && val < 10000) {\n      const newData = JSON.parse(JSON.stringify(data))\n      newData.words = val\n      return newData\n    } else {\n      // Otherwise, keep state the same\n      return false\n    }\n  }\n\n  // If the selection for new lines is changed, create a new version of state\n  changeNewline (checked, data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    newData.newline = checked\n    return newData\n  }\n\n  // If the selection for filtering duplicates is changed, create a new version of state\n  changeDupes (checked, data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    newData.filterdupes = checked\n    return newData\n  }\n\n  // Check the input for errors\n  checkErrors (data) {\n    let status = []\n\n    // Check Subpattern for circular reference\n    const getSp = selected => {\n      let sp = ''\n      for (let i = 0; i < data.subpatterns.length; i++) {\n        if (data.subpatterns[i].selected === selected) {\n          sp = data.subpatterns[i].subpattern\n          break\n        }\n      }\n      return sp\n    }\n\n    const idDeps = subpattern => {\n      const deps = []\n      for (let i = 0; i < subpattern.length; i++) {\n        if (vars.includes(subpattern[i])) {\n          deps.push(subpattern[i])\n        }\n      }\n      return Array.from(new Set(deps))\n    }\n\n    const checkCirc = (selected, refed) => {\n      const sp = getSp(selected)\n      const deps = idDeps(sp)\n      let circ = false\n\n      if (deps.length > 0) {\n        if (deps.includes(selected) || refed.includes(selected)) {\n          circ = true\n        } else {\n          let i = 0\n          refed.push(selected)\n          while (!circ && i < deps.length) {\n            circ = checkCirc(deps[i], refed)\n            i++\n          }\n        }\n      }\n\n      return circ\n    }\n\n    for (let i = 0; i < data.subpatterns.length; i++) {\n      const deps = idDeps(data.subpatterns[i].subpattern)\n      const refed = []\n\n      if (deps.length > 0) {\n        for (let j = 0; j < deps.length; j++) {\n          if (checkCirc(deps[j], refed)) {\n            status.push('The Subpatterns contain a circular reference.')\n            break\n          }\n        }\n      }\n    }\n\n    // Check for duplicate Subpattern variable names\n    let duplicates = []\n    for (let i = 0; i < data.subpatterns.length; i++) {\n      const current = data.subpatterns[i].selected\n\n      for (let j = 0; j < data.subpatterns.length; j++) {\n        if (i === j) {\n          continue\n        } else {\n          if (data.subpatterns[j].selected === current) {\n            duplicates.push(current)\n          }\n        }\n      }\n    }\n\n    duplicates = Array.from(new Set(duplicates))\n    const dupes = duplicates.join(', ')\n\n    if (duplicates.length > 1) {\n      status.push(\n        `Some Subpattern variables (${dupes}) have been used multiple times.`\n      )\n    } else if (duplicates.length === 1) {\n      status.push(\n        `The Subpattern variable ${dupes} has been used multiple times.`\n      )\n    }\n\n    // Check Pattern for undefined variable\n    const defed = []\n    for (let i = 0; i < data.subpatterns.length; i++) {\n      defed.push(data.subpatterns[i].selected)\n    }\n\n    const undefed = []\n    for (let i = 0; i < data.pattern.length; i++) {\n      if (vars.includes(data.pattern[i])) {\n        if (!defed.includes(data.pattern[i])) {\n          undefed.push(data.pattern[i])\n        }\n      }\n    }\n    for (let i = 0; i < data.subpatterns.length; i++) {\n      for (let j = 0; j < data.subpatterns[i].subpattern.length; j++) {\n        if (vars.includes(data.subpatterns[i].subpattern[j])) {\n          if (!defed.includes(data.subpatterns[i].subpattern[j])) {\n            undefed.push(data.subpatterns[i].subpattern[j])\n          }\n        }\n      }\n    }\n\n    const undefSet = Array.from(new Set(undefed))\n    const undefs = undefSet.join(', ')\n\n    if (undefSet.length > 1) {\n      // Update this status message once escaping characters is enabled\n      status.push(\n        `Some capital A–Z letters (${undefs}) were used but not defined as variables. If your intention is to include these characters as a letter in the results, a future version will allow this using escaped characters.`\n      )\n    } else if (undefSet.length === 1) {\n      status.push(\n        `The capital letter ${undefs} was used but not defined as a variable. If your intention is to include this character as a letter in the results, a future version will allow this using escaped characters.`\n      )\n    }\n\n    status = Array.from(new Set(status))\n    return status\n  }\n\n  // Start the generation process\n  generate (data) {\n    const status = this.checkErrors(data)\n    let results\n\n    if (status.length > 0) {\n      results = {\n        status: status,\n        results: [],\n        stats: {\n          words: 0,\n          maxWords: 0,\n          filtered: 0,\n          remaining: 0\n        }\n      }\n    } else {\n      results = this.build(data, ['ok'])\n    }\n\n    return results\n  }\n\n  // Generate the output\n  build (data, status) {\n    const results = []\n    const newData = JSON.parse(JSON.stringify(data))\n\n    // Randomly choose from the items in an array\n    const chooseRand = length => {\n      return Math.floor(Math.random() * length)\n    }\n\n    // Get the subpattern for a variable\n    const getSubpattern = (subpatterns, selected) => {\n      let subpattern = []\n      for (let i = 0; i < subpatterns.length; i++) {\n        if (subpatterns[i].selected === selected) {\n          subpattern = subpatterns[i].subpattern\n          break\n        }\n      }\n      return subpattern\n    }\n\n    // If a chosen item is a defined variable, randomly choose from its own Subpattern\n    const resolveVar = (subpatterns, selected) => {\n      let letter = ''\n      if (vars.includes(selected)) {\n        const subpattern = getSubpattern(subpatterns, selected)\n        const selection = subpattern[chooseRand(subpattern.length)]\n        if (vars.includes(selection)) {\n          letter = resolveVar(subpatterns, selection)\n        } else {\n          letter = selection\n        }\n      } else {\n        letter = selected\n      }\n      if (letter.length > 1) {\n        letter = resolveOpt(subpatterns, letter)\n      }\n      return letter\n    }\n\n    const resolveOpt = (subpatterns, option) => {\n      let letters = ''\n      for (let i = 0; i < option.length; i++) {\n        if (/[()[\\]^*\"]/.test(option[i])) {\n          // For now, ignore the characters that will be used for operations\n          continue\n        } else {\n          letters += resolveVar(subpatterns, option[i])\n        }\n      }\n      return letters\n    }\n\n    // Split all the Subpatterns into arrays based on '/'\n    for (let i = 0; i < newData.subpatterns.length; i++) {\n      newData.subpatterns[i].subpattern = newData.subpatterns[\n        i\n      ].subpattern.split('/')\n    }\n\n    // Split the Pattern into an array based on '/'\n    const pattArr = newData.pattern.split('/')\n\n    // Generate the number of words requested in the settings\n    for (let i = 0; i < newData.words; i++) {\n      let word = ''\n\n      // If the Pattern has options, choose one\n      const patt = pattArr[chooseRand(pattArr.length)]\n\n      word += resolveOpt(newData.subpatterns, patt)\n\n      results.push(word)\n    }\n\n    // Calculate the stats on the generated output\n\n    // Calculate the maximum number of words\n    let count = 0\n\n    for (let i = 0; i < pattArr.length; i++) {\n      let optCount = 1\n      if (pattArr[i].length === 0) {\n        optCount = 0\n        break\n      } else {\n        for (let j = 0; j < pattArr[i].length; j++) {\n          const variab = pattArr[i][j]\n          let addCount = 0\n          let multCount = 1\n          if (/[()[\\]^*\"]/.test(variab)) {\n            // For now, ignore the characters that will be used for operations\n            continue\n          } else if (!vars.includes(variab)) {\n            // If the current item in the Pattern is not a variable, add 1 to the count\n            addCount += 1\n          } else {\n            for (let k = 0; k < newData.subpatterns.length; k++) {\n              const subpattern = newData.subpatterns[k]\n              if (subpattern.selected === variab) {\n                // If the variable is defined, count how many options are in the Subpattern\n                multCount *= subpattern.subpattern.length\n                break\n              } else {\n                // If the variable is unused, skip it\n                continue\n              }\n            }\n          }\n          optCount *= multCount\n          optCount += addCount\n        }\n      }\n      count += optCount\n    }\n\n    // If there are results, count how many words there are\n    let words = 0\n    if (results[0].length !== 0) {\n      words = results.length\n    }\n\n    const filteredWords = Array.from(new Set(results))\n    const remaining = filteredWords.length\n    const filtered = newData.words - remaining\n\n    const response = {\n      status: status,\n      results: results,\n      stats: {\n        words: words,\n        maxWords: count,\n        filtered: filtered,\n        remaining: remaining\n      }\n    }\n\n    return response\n  }\n}\n\nconst genService = new GenService()\n\nexport default genService\n","import React, { useState } from 'react'\nimport { graphql, useStaticQuery } from 'gatsby'\n\nimport Tool from '../../components/tool'\n\nimport GenForm from '../../pageComponents/gen/genForm'\nimport GenResults from '../../pageComponents/gen/genResults'\nimport genService from '../../services/genService'\n\nimport styles from './gen.module.sass'\n\nexport const PureGen = ({ data }) => {\n  const toolInfo = data?.site?.siteMetadata?.toolInfo?.gen\n\n  // State\n\n  const [subpatterns, setSubpatterns] = useState(\n    genService.getData().subpatterns\n  )\n  const [pattern, setPattern] = useState(genService.getData().pattern)\n  const [words, setWords] = useState(genService.getData().words)\n  const [newline, setNewline] = useState(genService.getData().newline)\n  const [filterdupes, setFilterdupes] = useState(\n    genService.getData().filterdupes\n  )\n  const [status, setStatus] = useState(['ok'])\n  const [results, setResults] = useState([''])\n  const [stats, setStats] = useState({\n    words: 0,\n    maxWords: 0,\n    filtered: 0,\n    remaining: 0\n  })\n\n  // Functions\n\n  const onChangeInput = e => {\n    const newdata = {\n      subpatterns,\n      pattern,\n      words,\n      newline,\n      filterdupes\n    }\n\n    if (e.target.tagName === 'BUTTON') {\n      e.preventDefault()\n      if (e.target.type === 'submit') {\n        // Generate the output\n        const response = genService.generate(newdata)\n        setStatus(response.status)\n        setResults(response.results)\n        setStats(response.stats)\n        // Save the current state to storage\n        genService.setStorage(newdata)\n      } else if (e.target.type === 'button') {\n        if (e.target.id === 'save') {\n          // Save the current state to storage and generate a file\n          genService.save(newdata)\n        } else if (e.target.id === 'add') {\n          // When the add button is clicked, add a blank Subpattern to state\n          setSubpatterns(genService.add(newdata).subpatterns)\n        } else if (e.target.id.slice(0, 1) === 'c') {\n          // When a Subpattern is cleared, delete the corresponding Subpattern from state\n          const id = e.target.id.slice(1)\n          setSubpatterns(genService.clear(id, newdata).subpatterns)\n        }\n      }\n    } else if (e.target.type === 'file') {\n      e.preventDefault()\n      // Open a file and parse it to restore a saved state\n      const file = e.target.files[0]\n      const updateState = response => {\n        if (response) {\n          // Only change state if the file was successfully opened\n          setSubpatterns(response.subpatterns)\n          setPattern(response.pattern)\n          setWords(response.words)\n          setNewline(response.newline)\n          setFilterdupes(response.filterdupes)\n        }\n      }\n      genService.open(file, updateState)\n    } else if (e.target.type === 'checkbox') {\n      const checked = e.target.checked\n      if (e.target.id === 'newline') {\n        // If the selection for new lines is changed, store that change in state\n        setNewline(genService.changeNewline(checked, newdata).newline)\n      } else if (e.target.id === 'filterdupes') {\n        // If the selection for filtering duplicates is changed, store that change in state\n        setFilterdupes(genService.changeDupes(checked, newdata).filterdupes)\n      }\n    } else {\n      const val = e.target.value\n      if (e.target.id === 'pattern') {\n        // When the pattern is changed, store the change in state\n        setPattern(genService.changePattern(val, newdata).pattern)\n      } else if (e.target.id === 'words') {\n        // When the number of desired words is changed, store that change in state\n        const response = genService.wordNumChange(val, newdata)\n        if (response) {\n          // Only update state if there's a change\n          setWords(response.words)\n        }\n      } else {\n        const id = e.target.id.slice(1)\n        const which = e.target.id.slice(0, 1)\n        if (which === 'v') {\n          // When a Subpattern variable is changed, store that change in state\n          setSubpatterns(genService.changeSelect(id, val, newdata).subpatterns)\n        } else if (which === 'p') {\n          // When a Subpattern is changed, store that change in state\n          setSubpatterns(\n            genService.changeSubpattern(id, val, newdata).subpatterns\n          )\n        }\n      }\n    }\n  }\n\n  return (\n    <Tool toolInfo={toolInfo}>\n      <GenForm\n        styles={styles}\n        data={{\n          subpatterns,\n          pattern,\n          words,\n          newline,\n          filterdupes\n        }}\n        change={onChangeInput}\n      />\n      <GenResults\n        styles={styles}\n        newline={newline}\n        filterDupes={filterdupes}\n        status={status}\n        results={results}\n        stats={stats}\n      />\n    </Tool>\n  )\n}\n\nconst Gen = props => {\n  const data = useStaticQuery(graphql`\n    query GenToolQuery {\n      site {\n        siteMetadata {\n          toolInfo {\n            gen {\n              title\n              link\n              description\n            }\n          }\n        }\n      }\n    }\n  `)\n\n  return <PureGen {...props} data={data} />\n}\n\nexport default Gen\n"],"sourceRoot":""}