{"version":3,"sources":["webpack://langua/./src/pageComponents/deriv/derivForm.js","webpack://langua/./src/pageComponents/deriv/derivResults.js","webpack://langua/./src/services/derivService.js","webpack://langua/./src/pages/deriv/deriv.module.sass","webpack://langua/./src/pages/deriv/index.js"],"names":["styles","data","change","filePicker","React","lexemeRows","lexemes","map","lexeme","index","key","className","derivRow","type","id","name","lexemeInput","value","onChange","lexemeDefInput","definition","clearButton","onClick","ver","small","derivationRows","derivations","derivation","derivationInput","derivationGlossInput","gloss","derivationDefInput","addButton","which","addingRow","classNames","sharedStyles","columnLabel","wordLabel","definitionLabel","affixLabel","glossLabel","addedClasses","side","htmlFor","min","max","wordsInput","words","e","preventDefault","current","click","ref","possible","results","useState","hovered","setHovered","outputBox","item","i","term","affixGloss","hoveredGloss","onMouseOver","hoverAffix","onMouseOut","unhoverAffix","lexGloss","output","newWords","length","newWord","outputRow","rowNumber","prefix","suffix","error","affixDef","hoveredDef","toLocaleString","this","getData","bind","save","open","setStorage","add","clear","changeInput","derive","dataProcessor","fileProcessor","file","callback","response","window","FileReader","result","endsWith","lexemeSchema","schema","String","derivationSchema","DataSchema","Number","Array","of","content","JSON","parse","toast","autoClose","bodyClassName","progressClassName","console","errors","newData","stringify","push","num","splice","val","wordNumChange","filter","remaining","affix","replace","test","match","circum","split","attachAffix","base","Math","floor","random","list","randInd","randAff","deriveFromSingleBase","der","randLex","deriveFromSingleDerivation","getUniqueItem","newItem","isUnique","deriveFromAny","props","toolInfo","site","siteMetadata","deriv","derivService","setWords","setType","setLexemes","setDerivations","setResults","state","target","tagName","slice","idNum","files"],"mappings":"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","file":"component---src-pages-deriv-index-js-c20e85f3b602ebd89f82.js","sourcesContent":["import React from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Form from '../../components/form'\nimport Button from '../../components/button'\nimport Control from '../../components/control'\nimport ControlSide from '../../components/control/side'\nimport ControlPiece from '../../components/control/piece'\n\nimport sharedStyles from '../../components/form/sharedForm.module.sass'\n\nconst DerivForm = ({ styles, data, change }) => {\n  const filePicker = React.createRef()\n\n  const lexemeRows = data.lexemes.map((lexeme, index) => (\n    <div key={index} className={styles.derivRow}>\n      <input\n        type='text'\n        id={`lw${index}`}\n        name={`lw${index}`}\n        className={styles.lexemeInput}\n        value={lexeme.lexeme}\n        onChange={change}\n        aria-label={`Word for lexeme ${index}`}\n      />\n      <input\n        type='text'\n        id={`ld${index}`}\n        name={`ld${index}`}\n        className={styles.lexemeDefInput}\n        value={lexeme.definition}\n        onChange={change}\n        aria-label={`Gloss for lexeme ${index}`}\n      />\n      <div className={styles.clearButton}>\n        <Button\n          id={`lc${index}`}\n          onClick={change}\n          ver='danger'\n          small\n          type='button'\n          aria-label={`Delete lexeme ${index}`}\n        >\n          Delete\n        </Button>\n      </div>\n    </div>\n  ))\n\n  const derivationRows = data.derivations.map((derivation, index) => (\n    <div key={index} className={styles.derivRow}>\n      <input\n        type='text'\n        id={`da${index}`}\n        name={`da${index}`}\n        className={styles.derivationInput}\n        value={derivation.derivation}\n        onChange={change}\n        aria-label={`Affix ${index}`}\n      />\n      <input\n        type='text'\n        id={`dl${index}`}\n        name={`dl${index}`}\n        className={styles.derivationGlossInput}\n        value={derivation.gloss}\n        onChange={change}\n        aria-label={`Gloss for affix ${index}`}\n      />\n      <input\n        type='text'\n        id={`dd${index}`}\n        name={`dd${index}`}\n        className={styles.derivationDefInput}\n        value={derivation.definition}\n        onChange={change}\n        aria-label={`Definition for affix ${index}`}\n      />\n      <div className={styles.clearButton}>\n        <Button\n          id={`dc${index}`}\n          onClick={change}\n          ver='danger'\n          small\n          type='button'\n          aria-label={`Delete lexeme ${index}`}\n        >\n          Delete\n        </Button>\n      </div>\n    </div>\n  ))\n\n  const addButton = which => (\n    <div className={styles.addingRow}>\n      <Button\n        onClick={change}\n        id={`${which}Add`}\n        ver='success'\n        small\n        type='button'\n      >\n        Add\n      </Button>\n    </div>\n  )\n\n  const invokeFilePicker = e => {\n    e.preventDefault()\n    filePicker.current.value = ''\n    filePicker.current.click()\n  }\n\n  return (\n    <Form name='deriv-form'>\n      <div className={classNames(styles.lexemes, sharedStyles.part)}>\n        <h5 className={sharedStyles.sectionTitle}>Lexemes</h5>\n        <div className={styles.derivRow}>\n          <h6 className={classNames(styles.columnLabel, styles.wordLabel)}>\n            Word\n          </h6>\n          <h6\n            className={classNames(styles.columnLabel, styles.definitionLabel)}\n          >\n            Gloss\n          </h6>\n        </div>\n        {lexemeRows}\n        {addButton('lex')}\n      </div>\n      <div className={classNames(styles.derivations, sharedStyles.part)}>\n        <h5 className={sharedStyles.sectionTitle}>Derivational Affixes</h5>\n        <div className={styles.derivRow}>\n          <h6 className={classNames(styles.columnLabel, styles.affixLabel)}>\n            Affix\n          </h6>\n          <h6 className={classNames(styles.columnLabel, styles.glossLabel)}>\n            Gloss\n          </h6>\n          <h6\n            className={classNames(styles.columnLabel, styles.definitionLabel)}\n          >\n            Definition\n          </h6>\n        </div>\n        {derivationRows}\n        {addButton('der')}\n      </div>\n      <Control addedClasses={sharedStyles.part}>\n        <ControlSide side='left'>\n          <ControlPiece>\n            <Button type='submit' ver='neutral' onClick={change}>\n              Derive\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <label htmlFor='words'>number of words to derive:</label>\n            <input\n              type='number'\n              id='words'\n              name='words'\n              min='1'\n              max='9999'\n              className={styles.wordsInput}\n              value={data.words}\n              onChange={change}\n            />\n          </ControlPiece>\n          <ControlPiece>\n            <label htmlFor='type'>output type:</label>\n            <select id='type' name='type' value={data.type} onChange={change}>\n              <option value='any'>any base, any derivation</option>\n              <option value='single base'>single base</option>\n              <option value='single derivation'>single derivation</option>\n            </select>\n          </ControlPiece>\n        </ControlSide>\n        <ControlSide side='right'>\n          <ControlPiece>\n            <Button id='save' ver='success' onClick={change} type='button'>\n              Save\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <Button id='open' onClick={invokeFilePicker} type='button'>\n              Open\n            </Button>\n            <input\n              id='file'\n              name='file'\n              className={sharedStyles.hidden}\n              type='file'\n              ref={filePicker}\n              onChange={change}\n            />\n          </ControlPiece>\n        </ControlSide>\n      </Control>\n    </Form>\n  )\n}\n\nDerivForm.propTypes = {\n  styles: PropTypes.object,\n  data: PropTypes.shape({\n    words: PropTypes.number.isRequired,\n    type: PropTypes.oneOf(['any', 'single base', 'single derivation'])\n      .isRequired,\n    lexemes: PropTypes.arrayOf(\n      PropTypes.shape({\n        lexeme: PropTypes.string.isRequired,\n        definition: PropTypes.string.isRequired\n      })\n    ),\n    derivations: PropTypes.arrayOf(\n      PropTypes.shape({\n        derivation: PropTypes.string.isRequired,\n        gloss: PropTypes.string.isRequired,\n        definition: PropTypes.string.isRequired\n      })\n    )\n  }).isRequired,\n  change: PropTypes.func.isRequired\n}\n\nexport default DerivForm\n","import React, { useState } from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Results from '../../components/results'\n\nimport sharedStyles from '../../components/results/sharedResults.module.sass'\n\nconst DerivResults = ({ styles, results }) => {\n  const [hovered, setHovered] = useState(null)\n  const outputBox = (which, item, i) => {\n    if (which === 'affix') {\n      return (\n        <div className={styles.outputBox}>\n          <p className={styles.term}>{item.derivation}</p>\n          <p\n            className={classNames(\n              styles.affixGloss,\n              styles.gloss,\n              // Dynamically assign the hovered class if hovered\n              i === hovered ? styles.hoveredGloss : null\n            )}\n            onMouseOver={() => hoverAffix(i)}\n            onMouseOut={() => unhoverAffix(i)}\n          >\n            {item.gloss}\n          </p>\n        </div>\n      )\n    } else if (which === 'lexeme') {\n      return (\n        <div className={styles.outputBox}>\n          <p className={styles.term}>{item.lexeme}</p>\n          <p className={classNames(styles.lexGloss, styles.gloss)}>\n            {item.definition}\n          </p>\n        </div>\n      )\n    } else if (which === 'error') {\n      return (\n        <div className={styles.outputBox}>\n          <p className={classNames(sharedStyles.error, styles.gloss)}>{item}</p>\n        </div>\n      )\n    } else {\n      return null\n    }\n  }\n\n  const output = () => {\n    if (results) {\n      if (results.newWords.length) {\n        return results.newWords.map((newWord, i) => (\n          <div\n            key={i}\n            className={classNames(styles.derivRow, styles.outputRow)}\n          >\n            <div className={classNames(styles.outputBox, styles.rowNumber)}>\n              {i + 1}.\n            </div>\n            <div>\n              <div className={classNames(styles.derivRow, styles.outputRow)}>\n                {newWord.prefix ? outputBox('affix', newWord.prefix, i) : null}\n                {newWord.lexeme ? outputBox('lexeme', newWord.lexeme, i) : null}\n                {newWord.suffix ? outputBox('affix', newWord.suffix, i) : null}\n                {newWord.error ? outputBox('error', newWord.error, i) : null}\n              </div>\n              <p\n                className={classNames(\n                  styles.affixDef,\n                  // Dynamically assign the hovered class if hovered\n                  i === hovered ? styles.hoveredDef : null\n                )}\n              >\n                {newWord.prefix\n                  ? newWord.prefix.definition\n                  : newWord.suffix\n                  ? newWord.suffix.definition\n                  : ''}\n              </p>\n            </div>\n          </div>\n        ))\n      }\n    }\n\n    return null\n  }\n\n  const statsText = () => {\n    let words = 0\n    let possible = 0\n\n    if (results) {\n      words = results.newWords.length.toLocaleString()\n      possible = results.possible.toLocaleString()\n    }\n\n    return `words: ${words}; maximum derivations possible: ${possible}`\n  }\n\n  const hoverAffix = i => {\n    setHovered(i)\n  }\n\n  const unhoverAffix = i => {\n    setHovered(null)\n  }\n\n  return (\n    <Results>\n      <div className={styles.output}>{output()}</div>\n      <div className={sharedStyles.stats}>\n        <p className={sharedStyles.statsText}>{statsText()}</p>\n      </div>\n    </Results>\n  )\n}\n\nDerivResults.propTypes = {\n  styles: PropTypes.object,\n  results: PropTypes.shape({\n    newWords: PropTypes.arrayOf(\n      PropTypes.shape({\n        lexeme: PropTypes.shape({\n          lexeme: PropTypes.string.isRequired,\n          definition: PropTypes.string.isRequired\n        }).isRequired,\n        prefix: PropTypes.shape({\n          derivation: PropTypes.string.isRequired,\n          gloss: PropTypes.string.isRequired,\n          definition: PropTypes.string.isRequired\n        }),\n        suffix: PropTypes.shape({\n          derivation: PropTypes.string.isRequired,\n          gloss: PropTypes.string.isRequired,\n          definition: PropTypes.string.isRequired\n        }),\n        error: PropTypes.string\n      })\n    ),\n    possible: PropTypes.number\n  })\n}\n\nexport default DerivResults\n","import { toast } from 'react-toastify'\nimport schema from 'js-schema'\n\nimport dataProcessor from '../tools/dataProcessor'\nimport fileProcessor from '../tools/fileProcessor'\n\nclass DerivService {\n  constructor () {\n    this.item = 'deriv'\n    this.getData = this.getData.bind(this)\n    this.save = this.save.bind(this)\n    this.open = this.open.bind(this)\n    this.setStorage = this.setStorage.bind(this)\n    this.add = this.add.bind(this)\n    this.clear = this.clear.bind(this)\n    this.changeInput = this.changeInput.bind(this)\n    this.derive = this.derive.bind(this)\n  }\n\n  // Get the data from storage or from the default data\n  getData () {\n    return dataProcessor.getData(this.item)\n  }\n\n  // Store the current data in storage\n  setStorage (data) {\n    dataProcessor.setStorage(data, this.item)\n  }\n\n  // Save the current state to storage and generate a file\n  save (data) {\n    fileProcessor.save(data, this.item)\n  }\n\n  // Open a file and parse it to restore a saved state\n  open (file, callback) {\n    let response\n\n    const processResults = result => {\n      // If correct filetype\n      if (file.name.endsWith('.lngd')) {\n        // Define correct file structure\n        const lexemeSchema = schema({\n          lexeme: String,\n          definition: String\n        })\n\n        const derivationSchema = schema({\n          derivation: String,\n          gloss: String,\n          definition: String\n        })\n\n        const DataSchema = schema({\n          words: Number,\n          type: ['any', 'single base', 'single derivation'],\n          lexemes: Array.of(lexemeSchema),\n          derivations: Array.of(derivationSchema)\n        })\n\n        const content = JSON.parse(result)\n\n        if (content.results) {\n          content.results.words = +content.results.words\n        }\n\n        if (DataSchema(content)) {\n          // If the file's content contains valid Data, load it\n          toast.success(`Data loaded from ${file.name}.`, {\n            autoClose: 5000,\n            className: 'toast-opened',\n            bodyClassName: 'toast-opened-body',\n            progressClassName: 'toast-opened-progress'\n          })\n\n          this.setStorage(content)\n\n          response = content\n        } else {\n          // If the file's content does not contain valid Data, show an error\n          toast.warn(`The content of ${file.name} is invalid.`, {\n            autoClose: 5000,\n            className: 'toast-unopened',\n            bodyClassName: 'toast-unopened-body',\n            progressClassName: 'toast-unopened-progress'\n          })\n\n          // eslint-disable-next-line\n          console.error(DataSchema.errors(content))\n\n          response = false\n        }\n      } else {\n        // If incorrect filetype\n        toast.warn('Wrong filetype selected.', {\n          autoClose: 5000,\n          className: 'toast-unopened',\n          bodyClassName: 'toast-unopened-body',\n          progressClassName: 'toast-unopened-progress'\n        })\n\n        response = false\n      }\n\n      callback(response)\n    }\n\n    if (window.FileReader) {\n      // If the browser has access to the File APIs, open the file\n      fileProcessor.openFile(file, processResults)\n    } else {\n      // If the browser can't access the File APIs, display a notification\n      toast.warn('Your browser is unable to open files.', {\n        autoClose: 5000,\n        className: 'toast-unopened',\n        bodyClassName: 'toast-unopened-body',\n        progressClassName: 'toast-unopened-progress'\n      })\n\n      response = false\n      callback(response)\n    }\n  }\n\n  // Add a new row to the form\n  add (data, which) {\n    const newData = JSON.parse(JSON.stringify(data))\n    if (which === 'lex') {\n      newData.lexemes.push({ lexeme: '', definition: '' })\n    } else {\n      newData.derivations.push({ derivation: '', gloss: '', definition: '' })\n    }\n    return newData\n  }\n\n  // Remove a row from the form\n  clear (data, num, which) {\n    const newData = JSON.parse(JSON.stringify(data))\n    if (which === 'l') {\n      newData.lexemes.splice(num, 1)\n    } else {\n      newData.derivations.splice(num, 1)\n    }\n    return newData\n  }\n\n  // Update an input field\n  changeInput (data, num, which, val) {\n    const newData = JSON.parse(JSON.stringify(data))\n    switch (which) {\n      case 'lw':\n        newData.lexemes[num].lexeme = val\n        break\n      case 'ld':\n        newData.lexemes[num].definition = val\n        break\n      case 'da':\n        newData.derivations[num].derivation = val\n        break\n      case 'dl':\n        newData.derivations[num].gloss = val\n        break\n      case 'dd':\n        newData.derivations[num].definition = val\n        break\n      default:\n        break\n    }\n    return newData\n  }\n\n  // When the number of desired words is changed, create a new version of state\n  wordNumChange (data, val) {\n    val = +val\n    // Limit number entry to between 1 and 9999\n    if (val < 1) {\n      val = 1\n    } else if (val > 9999) {\n      val = 9999\n    }\n\n    // Only change state if the number is between 1 and 9999\n    if (val > 0 && val < 10000) {\n      const newData = JSON.parse(JSON.stringify(data))\n      newData.words = val\n      return newData\n    } else {\n      // Otherwise, keep state the same\n      return false\n    }\n  }\n\n  // Derive words from the data\n  derive (data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    // Compute the total possible number of results\n    const computePossible = filter => {\n      if (filter === 'single base') {\n        return newData.derivations.length\n      } else if (filter === 'single derivation') {\n        return newData.lexemes.length\n      } else {\n        return newData.lexemes.length * newData.derivations.length\n      }\n    }\n    const possible = computePossible(newData.type)\n    // If the user has selected to derive more than the total number possible, limit the results to the number that is possible\n    let remaining = newData.words > possible ? possible : newData.words\n\n    // Classify each of the affixes\n    const derivations = newData.derivations.map(affix => {\n      affix.derivation = affix.derivation.replace(/-+/g, '-')\n      if (/-/.test(affix.derivation)) {\n        // If the affix entered contains a hyphen\n        if (affix.derivation.match(/-/g).length === 1) {\n          // If the affix entered caintains no more than one hyphen\n          if (/-$/.test(affix.derivation)) {\n            // Prefix\n            affix.gloss = `${affix.gloss}-`\n            return { prefix: affix }\n          } else if (/^-/.test(affix.derivation)) {\n            // Suffix\n            affix.gloss = `-${affix.gloss}`\n            return { suffix: affix }\n          } else {\n            // Circumfix\n            const circum = affix.derivation.split(/-/)\n            const prefix = JSON.parse(JSON.stringify(affix))\n            const suffix = JSON.parse(JSON.stringify(affix))\n            prefix.derivation = `${circum[0]}-`\n            prefix.gloss = `${prefix.gloss}-`\n            suffix.derivation = `-${circum[1]}`\n            suffix.gloss = `-${suffix.gloss}`\n            return { prefix: prefix, suffix: suffix }\n          }\n        } else {\n          // If the affix entered contains more than one hyphen\n          return {\n            error: `The affix ${affix.derivation} contains too many hyphens.`\n          }\n        }\n      } else {\n        // If the affix entered contains no hyphens\n        return { error: `The affix ${affix.derivation} is missing a hyphen.` }\n      }\n    })\n\n    // Attach words to their affixes on the correct side(s)\n    const attachAffix = (lexeme, affix) => {\n      return {\n        prefix: affix.prefix,\n        lexeme: lexeme,\n        suffix: affix.suffix,\n        error: affix.error\n      }\n    }\n\n    // Derive from a single base\n    const deriveFromSingleBase = () => {\n      const base =\n        newData.lexemes[Math.floor(Math.random() * newData.lexemes.length)]\n      const list = []\n      while (remaining > 0) {\n        const randInd = Math.floor(Math.random() * derivations.length)\n        const randAff = derivations[randInd]\n        list.push(attachAffix(base, randAff))\n        derivations.splice(randInd, 1)\n        remaining--\n      }\n      return list\n    }\n\n    // Derive from a single derivation\n    const deriveFromSingleDerivation = () => {\n      const der = derivations[Math.floor(Math.random() * derivations.length)]\n      const list = []\n      while (remaining > 0) {\n        const randInd = Math.floor(Math.random() * newData.lexemes.length)\n        const randLex = newData.lexemes[randInd]\n        list.push(attachAffix(randLex, der))\n        newData.lexemes.splice(randInd, 1)\n        remaining--\n      }\n      return list\n    }\n\n    // Derive from any base and any derivation\n    const deriveFromAny = () => {\n      const list = []\n      // Find only unique pairs of lexemes and affixes\n      const getUniqueItem = () => {\n        const randLex =\n          newData.lexemes[Math.floor(Math.random() * newData.lexemes.length)]\n        const randAff =\n          derivations[Math.floor(Math.random() * derivations.length)]\n        let newItem = attachAffix(randLex, randAff)\n        let isUnique = true\n        for (let i = 0; i < list.length; i++) {\n          if (JSON.stringify(newItem) === JSON.stringify(list[i])) {\n            isUnique = false\n            break\n          }\n        }\n        if (!isUnique) {\n          newItem = getUniqueItem()\n        }\n        return newItem\n      }\n      while (remaining > 0) {\n        list.push(getUniqueItem())\n        remaining--\n      }\n      return list\n    }\n\n    if (newData.type === 'single base') {\n      return { newWords: deriveFromSingleBase(), possible: possible }\n    } else if (newData.type === 'single derivation') {\n      return { newWords: deriveFromSingleDerivation(), possible: possible }\n    } else {\n      return { newWords: deriveFromAny(), possible: possible }\n    }\n  }\n}\n\nconst derivService = new DerivService()\n\nexport default derivService\n","// extracted by mini-css-extract-plugin\nexport default {\"wordsInput\":\"deriv-module--words-input--3_pLI\",\"derivRow\":\"deriv-module--deriv-row--1FFeo\",\"addingRow\":\"deriv-module--adding-row--sX2At\",\"outputRow\":\"deriv-module--output-row--3vdh4\",\"columnLabel\":\"deriv-module--column-label--35gi5\",\"lexemeInput\":\"deriv-module--lexeme-input--16dBy\",\"wordLabel\":\"deriv-module--word-label--1lbrW\",\"derivationGlossInput\":\"deriv-module--derivation-gloss-input--2GHha\",\"glossLabel\":\"deriv-module--gloss-label--1Z2GZ\",\"lexemeDefInput\":\"deriv-module--lexeme-def-input--2xyWj\",\"definitionLabel\":\"deriv-module--definition-label--NOxBT\",\"derivationDefInput\":\"deriv-module--derivation-def-input--3ZtSX\",\"derivationInput\":\"deriv-module--derivation-input--22_N2\",\"affixLabel\":\"deriv-module--affix-label--1h9ZC\",\"outputBox\":\"deriv-module--output-box--1WN2x\",\"rowNumber\":\"deriv-module--row-number--1EVu1\",\"term\":\"deriv-module--term--MwRlp\",\"gloss\":\"deriv-module--gloss--2Y62Y\",\"lexGloss\":\"deriv-module--lex-gloss--2o52m\",\"affixGloss\":\"deriv-module--affix-gloss--EICTR\",\"affixDef\":\"deriv-module--affix-def--xtHjE\",\"hoveredGloss\":\"deriv-module--hovered-gloss--3Fqw9\",\"hoveredDef\":\"deriv-module--hovered-def--Ozs0j\"};","import React, { useState } from 'react'\nimport { graphql } from 'gatsby'\n\nimport Tool from '../../components/tool'\n\nimport DerivForm from '../../pageComponents/deriv/derivForm'\nimport DerivResults from '../../pageComponents/deriv/derivResults'\nimport derivService from '../../services/derivService'\n\nimport styles from './deriv.module.sass'\n\nexport const pageQuery = graphql`\nquery DerivToolQuery {\n  site {\n    siteMetadata {\n      toolInfo {\n        deriv {\n          title\n          link\n          description\n        }\n      }\n    }\n  }\n}\n`\n\nconst Deriv = props => {\n  const toolInfo = props.data?.site?.siteMetadata?.toolInfo?.deriv\n\n  // State\n\n  const [words, setWords] = useState(derivService.getData().words)\n  const [type, setType] = useState(derivService.getData().type)\n  const [lexemes, setLexemes] = useState(derivService.getData().lexemes)\n  const [derivations, setDerivations] = useState(\n    derivService.getData().derivations\n  )\n  const [results, setResults] = useState(derivService.getData().results)\n\n  // Functions\n\n  const onChange = e => {\n    const state = { words, type, lexemes, derivations, results }\n    if (e.target.tagName === 'BUTTON') {\n      e.preventDefault()\n      if (e.target.type === 'submit') {\n        // Derive the output\n        const response = derivService.derive(state)\n        state.results = response\n        setResults(response)\n        // Save the current state to storage\n        derivService.setStorage(state)\n      } else if (e.target.id === 'save') {\n        // Save the current state to storage and generate a file\n        derivService.save(state)\n      } else if (e.target.id.slice(3) === 'Add') {\n        const which = e.target.id.slice(0, 3)\n        // When the add button is clicked, add a blank row to state\n        const newData = derivService.add(state, which)\n        setLexemes(newData.lexemes)\n        setDerivations(newData.derivations)\n      } else if (e.target.id.slice(1, 2) === 'c') {\n        // When a row is cleared, delete teh corresponding row from state\n        const idNum = e.target.id.slice(2)\n        const which = e.target.id.slice(0, 1)\n        const newData = derivService.clear(state, idNum, which)\n        setLexemes(newData.lexemes)\n        setDerivations(newData.derivations)\n      }\n    } else if (e.target.type === 'file') {\n      e.preventDefault()\n      // Open a file and parse it to restore saved state\n      const file = e.target.files[0]\n      const updateState = response => {\n        if (response) {\n          // Only change state if the file was successfully opened\n          setWords(response.words)\n          setType(response.type)\n          setLexemes(response.lexemes)\n          setDerivations(response.derivations)\n          setResults(response.results)\n        }\n      }\n\n      derivService.open(file, updateState)\n    } else {\n      const idNum = e.target.id.slice(2)\n      const which = e.target.id.slice(0, 2)\n      const val = e.target.value\n      const name = e.target.name\n      if (\n        which === 'lw' ||\n        which === 'ld' ||\n        which === 'da' ||\n        which === 'dl' ||\n        which === 'dd'\n      ) {\n        const response = derivService.changeInput(state, idNum, which, val)\n        if (response) {\n          // Only change state if the input was successfully changed\n          setWords(response.words)\n          setType(response.type)\n          setLexemes(response.lexemes)\n          setDerivations(response.derivations)\n          setResults(response.results)\n        }\n      } else if (name === 'words') {\n        const response = derivService.wordNumChange(state, val)\n        if (response) {\n          // Only change state if the word number was successfully changed\n          setWords(response.words)\n          setType(response.type)\n          setLexemes(response.lexemes)\n          setDerivations(response.derivations)\n          setResults(response.results)\n        }\n      } else {\n        if (name === 'type') {\n          setType(val)\n        }\n      }\n    }\n  }\n\n  return (\n    <Tool toolInfo={toolInfo}>\n      <DerivForm\n        styles={styles}\n        data={{ words, type, lexemes, derivations }}\n        change={onChange}\n      />\n      <DerivResults styles={styles} results={results} />\n    </Tool>\n  )\n}\n\nexport default Deriv\n"],"sourceRoot":""}