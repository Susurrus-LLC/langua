{"version":3,"sources":["webpack://langua/./src/components/notice/notice.module.sass","webpack://langua/./src/components/notice/index.js","webpack://langua/./src/pageComponents/morph/morphForm.js","webpack://langua/./src/pageComponents/morph/morphResults.js","webpack://langua/./src/services/morphService.js","webpack://langua/./src/pages/morph/morph.module.sass","webpack://langua/./src/pages/morph/index.js"],"names":["children","className","styles","data","change","morph","check","save","open","filePicker","React","join","name","section","classNames","categories","inputSection","sharedStyles","container","id","categoriesInput","dataInput","value","onChange","textAreaSpacer","rewriteRules","rewriteRulesInput","soundChanges","soundChangesInput","lexicon","lexiconInput","addedClasses","side","type","ver","onClick","htmlFor","outputFormat","checked","showChanges","showDiff","ruleReport","rewriteOutput","e","preventDefault","current","click","ref","stats","results","resultsArr","output","map","error","i","outText","key","classes","result","diff","input","different","changed","length","trim","String","fromCharCode","format","outputText","totalWords","unchangedWords","differentWords","total","same","countStats","unchanged","this","item","getData","bind","removeResults","setStorage","splitRewriteRules","rewriteCats","splitCategories","rewriteChanges","splitSoundChanges","rewriteLex","unrewriteLex","applyChanges","getResults","idDiff","dataProcessor","dataNoResults","JSON","parse","stringify","fileProcessor","file","callback","response","window","FileReader","endsWith","DataSchema","schema","Array","of","Boolean","content","words","toast","autoClose","bodyClassName","progressClassName","console","errors","rules","splitRules","split","push","rewriteFrom","rewriteTo","cat","RegExp","replace","cats","assignments","rwSplit","thisCat","variable","newChange","prop","hasOwnProperty","changes","splitChanges","idChar","char","thisRule","changeFrom","changeTo","context","test","exec","exception","rwRule","changeFromArr","j","changeFromID","changeToArr","changeToID","contextArr","contextID","exceptionArr","exceptionID","lex","newLex","word","regRule","newResults","newWord","rpfc","rptc","rpe","reg","rwOutput","rwLexicon","undefined","newData","allErrors","concat","props","toolInfo","site","siteMetadata","useState","morphService","setCategories","setRewriteRules","setSoundChanges","setLexicon","setOutputFormat","setShowDiff","setShowChanges","setRuleReport","setRewriteOutput","setResults","val","target","state","files"],"mappings":"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","file":"component---src-pages-morph-index-js-bd22a3d26185ff5c1f97.js","sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"notice\":\"notice-module--notice--1QCeC\"};","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport styles from './notice.module.sass'\n\nconst Notice = ({ children }) => <p className={styles.notice}>{children}</p>\n\nNotice.propTypes = {\n  children: PropTypes.string\n}\n\nexport default Notice\n","import React from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Form from '../../components/form'\nimport Button from '../../components/button'\nimport Control from '../../components/control'\nimport ControlSide from '../../components/control/side'\nimport ControlPiece from '../../components/control/piece'\n\nimport sharedStyles from '../../components/form/sharedForm.module.sass'\n\nconst MorphForm = ({ styles, data, change, morph, check, save, open }) => {\n  const filePicker = React.createRef()\n\n  const join = data => data.join('\\n')\n\n  const invokeFilePicker = e => {\n    e.preventDefault()\n    filePicker.current.value = ''\n    filePicker.current.click()\n  }\n\n  return (\n    <Form name='morph-form'>\n      <div className={styles.section}>\n        <div\n          className={classNames(\n            styles.categories,\n            styles.inputSection,\n            sharedStyles.part\n          )}\n        >\n          <h5 className={sharedStyles.sectionTitle}>Categories</h5>\n          <div className={styles.container}>\n            <textarea\n              id='categories'\n              name='categories'\n              className={classNames(styles.categoriesInput, styles.dataInput)}\n              value={join(data.categories)}\n              onChange={change}\n              aria-label='Categories'\n            />\n            <div className={styles.textAreaSpacer}>\n              {join(data.categories)}&nbsp;\n            </div>\n          </div>\n        </div>\n        <div\n          className={classNames(\n            styles.rewriteRules,\n            styles.inputSection,\n            sharedStyles.part\n          )}\n        >\n          <h5 className={sharedStyles.sectionTitle}>Rewrite Rules</h5>\n          <div className={styles.container}>\n            <textarea\n              id='rewriteRules'\n              name='rewriteRules'\n              className={classNames(styles.rewriteRulesInput, styles.dataInput)}\n              value={join(data.rewriteRules)}\n              onChange={change}\n              aria-label='Rewrite rules'\n            />\n            <div className={styles.textAreaSpacer}>\n              {join(data.rewriteRules)}&nbsp;\n            </div>\n          </div>\n        </div>\n        <div\n          className={classNames(\n            styles.soundChanges,\n            styles.inputSection,\n            sharedStyles.part\n          )}\n        >\n          <h5 className={sharedStyles.sectionTitle}>Sound Changes</h5>\n          <div className={styles.container}>\n            <textarea\n              id='soundChanges'\n              name='soundChanges'\n              className={classNames(styles.soundChangesInput, styles.dataInput)}\n              value={join(data.soundChanges)}\n              onChange={change}\n              aria-label='Sound changes'\n            />\n            <div className={styles.textAreaSpacer}>\n              {join(data.soundChanges)}&nbsp;\n            </div>\n          </div>\n        </div>\n        <div\n          className={classNames(\n            styles.lexicon,\n            styles.inputSection,\n            sharedStyles.part\n          )}\n        >\n          <h5 className={sharedStyles.sectionTitle}>Lexicon</h5>\n          <div className={styles.container}>\n            <textarea\n              id='lexicon'\n              name='lexicon'\n              className={classNames(styles.lexiconInput, styles.dataInput)}\n              value={join(data.lexicon)}\n              onChange={change}\n              aria-label='Lexicon'\n            />\n            <div className={styles.textAreaSpacer}>\n              {join(data.lexicon)}&nbsp;\n            </div>\n          </div>\n        </div>\n      </div>\n      <Control addedClasses={sharedStyles.part}>\n        <ControlSide side='left'>\n          <ControlPiece>\n            <Button type='submit' ver='neutral' onClick={morph}>\n              Change\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <label htmlFor='outputFormat'>output format:</label>\n            <select\n              id='outputFormat'\n              name='outputFormat'\n              value={data.outputFormat}\n              onChange={change}\n            >\n              <option value='oo'>output</option>\n              <option value='io'>input &rarr; output</option>\n              <option value='oi'>output &larr; input</option>\n            </select>\n          </ControlPiece>\n          <ControlPiece>\n            <div>\n              <label>\n                <input\n                  type='checkbox'\n                  id='showChanges'\n                  name='options'\n                  value='showChanges'\n                  checked={data.showChanges}\n                  onChange={check}\n                />{' '}\n                italicize changes\n              </label>\n              <br />\n              <label>\n                <input\n                  type='checkbox'\n                  id='showDiff'\n                  name='options'\n                  value='showDiff'\n                  checked={data.showDiff}\n                  onChange={check}\n                />{' '}\n                bold differences\n              </label>\n            </div>\n          </ControlPiece>\n          <ControlPiece>\n            <div>\n              <label>\n                <input\n                  type='checkbox'\n                  id='ruleReport'\n                  name='options'\n                  value='ruleReport'\n                  checked={data.ruleReport}\n                  onChange={check}\n                />{' '}\n                report applied rules\n              </label>\n              <br />\n              <label>\n                <input\n                  type='checkbox'\n                  id='rewriteOutput'\n                  name='options'\n                  value='rewriteOutput'\n                  checked={data.rewriteOutput}\n                  onChange={check}\n                />{' '}\n                rewrite on output\n              </label>\n            </div>\n          </ControlPiece>\n        </ControlSide>\n        <ControlSide side='right'>\n          <ControlPiece>\n            <Button id='save' ver='success' onClick={save} type='button'>\n              Save\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <Button id='open' onClick={invokeFilePicker} type='button'>\n              Open\n            </Button>\n            <input\n              id='file'\n              name='file'\n              className={sharedStyles.hidden}\n              type='file'\n              ref={filePicker}\n              onChange={open}\n            />\n          </ControlPiece>\n        </ControlSide>\n      </Control>\n    </Form>\n  )\n}\n\nMorphForm.propTypes = {\n  styles: PropTypes.object,\n  data: PropTypes.shape({\n    categories: PropTypes.arrayOf(PropTypes.string).isRequired,\n    rewriteRules: PropTypes.arrayOf(PropTypes.string).isRequired,\n    soundChanges: PropTypes.arrayOf(PropTypes.string).isRequired,\n    lexicon: PropTypes.arrayOf(PropTypes.string).isRequired,\n    outputFormat: PropTypes.oneOf(['oo', 'io', 'oi']).isRequired,\n    showDiff: PropTypes.bool.isRequired,\n    showChanges: PropTypes.bool.isRequired,\n    ruleReport: PropTypes.bool.isRequired,\n    rewriteOutput: PropTypes.bool.isRequired\n  }).isRequired,\n  change: PropTypes.func.isRequired,\n  morph: PropTypes.func.isRequired,\n  check: PropTypes.func.isRequired,\n  save: PropTypes.func.isRequired,\n  open: PropTypes.func.isRequired\n}\n\nexport default MorphForm\n","import React from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Results from '../../components/results'\n\nimport sharedStyles from '../../components/results/sharedResults.module.sass'\n\nconst MorphResults = ({\n  styles,\n  outputFormat,\n  results,\n  showDiff,\n  showChanges\n}) => {\n  const resultsArr = results || []\n\n  const outputText = () => {\n    // If there were errors, print them\n    if (typeof resultsArr[0] === 'string') {\n      return resultsArr.map((error, i) => (\n        <p className={classNames(styles.outText, sharedStyles.error)} key={i}>\n          {error}\n        </p>\n      ))\n    }\n\n    // Format the results according to the selected option\n    const format = result => {\n      if (outputFormat === 'oo') {\n        return result.output.trim()\n      } else if (outputFormat === 'io') {\n        return `${result.input.trim()} ${String.fromCharCode(\n          8594\n        )} ${result.output.trim()}`\n      } else if (outputFormat === 'oi') {\n        return `${result.output.trim()} ${String.fromCharCode(\n          8592\n        )} ${result.input.trim()}`\n      }\n    }\n\n    // Assign the 'different' and 'changed' classes appropriately\n    const classes = result => {\n      if (showDiff && result.diff) {\n        if (showChanges && result.input !== result.output) {\n          return classNames(styles.outText, styles.different, styles.changed)\n        } else {\n          return classNames(styles.outText, styles.different)\n        }\n      } else {\n        if (showChanges && result.input !== result.output) {\n          return classNames(styles.outText, styles.changed)\n        } else {\n          return styles.outText\n        }\n      }\n    }\n\n    // Return the results text\n    return resultsArr.length > 0 ? (\n      resultsArr.map((result, i) => (\n        <p className={classes(result)} key={i}>\n          {format(result)}\n        </p>\n      ))\n    ) : (\n      <p className={styles.outText} />\n    )\n  }\n\n  const countStats = () => {\n    const totalWords = resultsArr.length\n    let unchangedWords = 0\n    let differentWords = 0\n    for (let i = 0; i < totalWords; i++) {\n      if (resultsArr[i].input === resultsArr[i].output) {\n        unchangedWords++\n      }\n\n      if (resultsArr[i].diff) {\n        differentWords++\n      }\n    }\n\n    const changedWords = totalWords - unchangedWords\n    const sameWords = totalWords - differentWords\n\n    return {\n      total: totalWords,\n      changed: changedWords,\n      unchangedWords: unchangedWords,\n      different: differentWords,\n      same: sameWords\n    }\n  }\n\n  const statsText = () => {\n    const stats = countStats()\n    return `${stats.changed} of ${stats.total} words changed (${stats.unchanged} unchanged); ${stats.different} of ${stats.total} words different from last time (${stats.same} the same)`\n  }\n\n  return (\n    <Results>\n      <div className={styles.output}>{outputText()}</div>\n      <div className={sharedStyles.stats}>\n        <p className={sharedStyles.statsText}>{statsText()}</p>\n      </div>\n    </Results>\n  )\n}\n\nMorphResults.propTypes = {\n  styles: PropTypes.object,\n  outputFormat: PropTypes.string.isRequired,\n  results: PropTypes.oneOfType([\n    PropTypes.arrayOf(\n      PropTypes.shape({\n        input: PropTypes.string.isRequired,\n        output: PropTypes.string.isRequired,\n        diff: PropTypes.bool.isRequired\n      })\n    ).isRequired,\n    PropTypes.arrayOf(PropTypes.string.isRequired).isRequired\n  ]),\n  showDiff: PropTypes.bool.isRequired,\n  showChanges: PropTypes.bool.isRequired\n}\n\nexport default MorphResults\n","import { toast } from 'react-toastify'\nimport schema from 'js-schema'\n\nimport dataProcessor from '../tools/dataProcessor'\nimport fileProcessor from '../tools/fileProcessor'\n\nclass MorphService {\n  constructor () {\n    this.item = 'morph'\n    this.getData = this.getData.bind(this)\n    this.removeResults = this.removeResults.bind(this)\n    this.setStorage = this.setStorage.bind(this)\n    this.save = this.save.bind(this)\n    this.open = this.open.bind(this)\n    this.splitRewriteRules = this.splitRewriteRules.bind(this)\n    this.rewriteCats = this.rewriteCats.bind(this)\n    this.splitCategories = this.splitCategories.bind(this)\n    this.rewriteChanges = this.rewriteChanges.bind(this)\n    this.splitSoundChanges = this.splitSoundChanges.bind(this)\n    this.rewriteLex = this.rewriteLex.bind(this)\n    this.unrewriteLex = this.unrewriteLex.bind(this)\n    this.applyChanges = this.applyChanges.bind(this)\n    this.getResults = this.getResults.bind(this)\n    this.idDiff = this.idDiff.bind(this)\n    this.morph = this.morph.bind(this)\n  }\n\n  // Get the data from storage or from the default data\n  getData () {\n    return dataProcessor.getData(this.item)\n  }\n\n  // Remove the results from the data\n  removeResults (data) {\n    const dataNoResults = JSON.parse(JSON.stringify(data))\n    delete dataNoResults.results\n    return dataNoResults\n  }\n\n  // Store the current data in storage\n  setStorage (data) {\n    dataProcessor.setStorage(this.removeResults(data), this.item)\n  }\n\n  // Save the current state to storage and generate a file\n  save (data) {\n    fileProcessor.save(this.removeResults(data), this.item)\n  }\n\n  // Open a file and parse it to restore a saved state\n  open (file, callback) {\n    let response\n\n    const processResults = result => {\n      // If correct filetype\n      if (file.name.endsWith('.lngm')) {\n        // Define correct file structure\n        const DataSchema = schema({\n          categories: Array.of(String),\n          rewriteRules: Array.of(String),\n          soundChanges: Array.of(String),\n          lexicon: Array.of(String),\n          outputFormat: ['oo', 'io', 'oi'],\n          showDiff: Boolean,\n          ruleReport: Boolean,\n          rewriteOutput: Boolean\n        })\n\n        const content = JSON.parse(result)\n\n        if (content.results) {\n          content.results.words = +content.results.words\n        }\n\n        if (DataSchema(content)) {\n          // If the file's content contains valid Data, load it\n          toast.success(`Data loaded from ${file.name}.`, {\n            autoClose: 5000,\n            className: 'toast-opened',\n            bodyClassName: 'toast-opened-body',\n            progressClassName: 'toast-opened-progress'\n          })\n\n          this.setStorage(content)\n\n          response = content\n        } else {\n          // If the file's content does not contain valid Data, show an error\n          toast.warn(`The content of ${file.name} is invalid.`, {\n            autoClose: 5000,\n            className: 'toast-unopened',\n            bodyClassName: 'toast-unopened-body',\n            progressClassName: 'toast-unopened-progress'\n          })\n\n          // eslint-disable-next-line\n          console.error(DataSchema.errors(content))\n\n          response = false\n        }\n      } else {\n        // If incorrect filetype\n        toast.warn('Wrong filetype selected.', {\n          autoClose: 5000,\n          className: 'toast-unopened',\n          bodyClassName: 'toast-unopened-body',\n          progressClassName: 'toast-unopened-progress'\n        })\n\n        response = false\n      }\n\n      callback(response)\n    }\n\n    if (window.FileReader) {\n      // If the browser has access to the File APIs, open the file\n      fileProcessor.openFile(file, processResults)\n    } else {\n      // If the browser can't access the File APIs, display a notification\n      toast.warn('Your browser is unable to open files.', {\n        autoClose: 5000,\n        className: 'toast-unopened',\n        bodyClassName: 'toast-unopened-body',\n        progressClassName: 'toast-unopened-progress'\n      })\n\n      response = false\n      callback(response)\n    }\n  }\n\n  // Split the rewrite rules into an array of objects\n  splitRewriteRules (rules) {\n    const splitRules = []\n    const errors = []\n\n    for (let i = 0; i < rules.length; i++) {\n      const split = rules[i].split('=')\n      if (split.length > 2) {\n        // If the string was split too many times, it had too many =\n        errors.push(`The rewrite rule ${rules[i]} has too many = signs.`)\n      } else if (split.length < 2) {\n        if (rules[i].length === 0) {\n          // If it was a blank line, ignore it\n          continue\n        } else {\n          // If the string wasn't split at all, it was missing a =\n          errors.push(`The rewrite rule ${rules[i]} is missing an = sign.`)\n        }\n      } else {\n        // Split the rewrite rule\n        splitRules.push({ rewriteFrom: split[0], rewriteTo: split[1] })\n      }\n    }\n\n    // If there are any errors that were logged, return the errors. Otherwise, return the split categories.\n    return errors.length ? errors : splitRules\n  }\n\n  // Apply the rewrite rules to the categories\n  rewriteCats (cat, rules) {\n    for (let i = 0; i < rules.length; i++) {\n      const rewriteFrom = new RegExp(rules[i].rewriteFrom, 'g')\n      cat[1] = cat[1].replace(rewriteFrom, rules[i].rewriteTo)\n    }\n    return cat\n  }\n\n  // Split the categories into an array of objects\n  splitCategories (cats, rules) {\n    const assignments = []\n    const errors = []\n\n    for (let i = 0; i < cats.length; i++) {\n      const split = cats[i].split('=')\n      if (split.length > 2) {\n        // If the string was split too many times, it had too many =\n        errors.push(`The category ${cats[i]} has too many = signs.`)\n      } else if (split.length < 2) {\n        if (cats[i].length === 0) {\n          // If it was a blank line, ignore it\n          continue\n        } else {\n          // If the string wasn't split at all, it was missing a =\n          errors.push(`The category ${cats[i]} is missing an = sign.`)\n        }\n      } else if (split[0].length > 1) {\n        // If the string to the left of the = is more than one character\n        errors.push(\n          `The category ${cats[i]} needs to be assigned to a single-character variable.`\n        )\n      } else {\n        const rwSplit = this.rewriteCats(split, rules)\n        // Split the variable from its assignments\n        assignments.push(rwSplit)\n      }\n    }\n\n    const splitCategories = []\n    for (let i = 0; i < assignments.length; i++) {\n      const thisCat = {}\n      thisCat.variable = assignments[i][0]\n      thisCat.categories = assignments[i][1].split('')\n      splitCategories.push(thisCat)\n    }\n\n    // If there are any errors that were logged, return the errors. Otherwise, return the split categories.\n    return errors.length ? errors : splitCategories\n  }\n\n  // Apply the rewrite rules to the sound change rules\n  rewriteChanges (change, rules) {\n    const newChange = JSON.parse(JSON.stringify(change))\n\n    for (const prop in newChange) {\n      if (newChange.hasOwnProperty(prop)) {\n        for (let i = 0; i < rules.length; i++) {\n          const rewriteFrom = new RegExp(rules[i].rewriteFrom, 'g')\n          newChange[prop] = newChange[prop].replace(\n            rewriteFrom,\n            rules[i].rewriteTo\n          )\n        }\n      }\n    }\n\n    return newChange\n  }\n\n  // Split the sound change rules into an array of objects\n  splitSoundChanges (cats, changes, rules) {\n    const splitChanges = []\n    const errors = []\n\n    const idChar = char => {\n      let cat = false\n      switch (char) {\n        case '_':\n          return 'target'\n        case '#':\n          return 'wordboundary'\n        case '[':\n          return 'brackopen'\n        case ']':\n          return 'brackclose'\n        case '(':\n          return 'parenopen'\n        case ')':\n          return 'parenclose'\n        default:\n          for (let i = 0; i < cats.length; i++) {\n            if (char === cats[i].variable) {\n              cat = true\n              break\n            }\n          }\n          return cat ? 'category' : 'literal'\n      }\n    }\n\n    for (let i = 0; i < changes.length; i++) {\n      const split = changes[i].split('/')\n      if (split.length > 4) {\n        // If hte string was split too many times, it had too many /\n        errors.push(`The sound change ${changes[i]} has too many / signs.`)\n      } else if (split.length < 2) {\n        if (changes[i].length === 0) {\n          // If it was a blank line, ignore it\n          continue\n        } else {\n          // If the string wasn't split at all, it was missing a /\n          errors.push(`The sound change ${changes[i]} is missing a / sign.`)\n        }\n      } else {\n        // Split the sound change rule into an object\n        const thisRule = {\n          changeFrom: split[0],\n          changeTo: split[1]\n        }\n        if (split[2]) {\n          thisRule.context = split[2]\n          if (!/_/.test(split[2])) {\n            errors.push(\n              `The context in the sound change ${changes[i]} is missing an _ sign.`\n            )\n          } else if (/_/.exec(split[2]).length > 2) {\n            errors.push(\n              `The context in the sound change ${changes[i]} has too many _ signs.`\n            )\n          }\n        }\n        if (split[3]) {\n          thisRule.exception = split[3]\n          if (!/_/.test(split[3])) {\n            errors.push(\n              `The exception in the sound change ${changes[i]} is missing an _ sign.`\n            )\n          } else if (/_/.exec(split[3]).length > 2) {\n            errors.push(\n              `The exception in the sound change ${changes[i]} has too many _ signs.`\n            )\n          }\n        }\n\n        const rwRule = this.rewriteChanges(thisRule, rules)\n\n        // ID all characters in each rule\n        const changeFromArr = []\n        for (let j = 0; j < rwRule.changeFrom.length; j++) {\n          changeFromArr.push(idChar(rwRule.changeFrom[j]))\n        }\n        rwRule.changeFromID = changeFromArr\n        const changeToArr = []\n        for (let j = 0; j < rwRule.changeTo.length; j++) {\n          changeToArr.push(idChar(rwRule.changeTo[j]))\n        }\n        rwRule.changeToID = changeToArr\n        const contextArr = []\n        if (rwRule.context) {\n          for (let j = 0; j < rwRule.context.length; j++) {\n            contextArr.push(idChar(rwRule.context[j]))\n          }\n          rwRule.contextID = contextArr\n        }\n        const exceptionArr = []\n        if (rwRule.exception) {\n          for (let j = 0; j < rwRule.exception.length; j++) {\n            exceptionArr.push(idChar(rwRule.exception[j]))\n          }\n          rwRule.exceptionID = exceptionArr\n        }\n\n        splitChanges.push(rwRule)\n      }\n    }\n\n    // If there are any errors that were logged, return the errors. Otherwise, return the split categories.\n    return errors.length ? errors : splitChanges\n  }\n\n  // Apply the rewrite rules to the lexicon\n  rewriteLex (lex, rules) {\n    const newLex = []\n\n    for (let i = 0; i < lex.length; i++) {\n      let word = lex[i]\n\n      for (let j = 0; j < rules.length; j++) {\n        const regRule = new RegExp(rules[j].rewriteFrom, 'g')\n        word = word.replace(regRule, rules[j].rewriteTo)\n      }\n\n      newLex.push(word)\n    }\n\n    return newLex\n  }\n\n  // Reverse-apply the rewrite rules to the output\n  unrewriteLex (results, rules) {\n    const newResults = JSON.parse(JSON.stringify(results))\n\n    for (let i = 0; i < newResults.length; i++) {\n      for (let j = 0; j < rules.length; j++) {\n        const regRule = new RegExp(rules[j].rewriteTo, 'g')\n        newResults[i].output = newResults[i].output.replace(\n          regRule,\n          rules[j].rewriteFrom\n        )\n      }\n    }\n\n    return newResults\n  }\n\n  // Apply the sound changes to a given word\n  applyChanges (cats, changes, word) {\n    let newWord = word\n\n    // For each rule\n    for (let i = 0; i < changes.length; i++) {\n      // Replace the # word boundary symbol with the regex \\b\n      const context = changes[i].context\n        ? changes[i].context.replace(/#/g, '\\\\b')\n        : undefined\n      const exception = changes[i].exception\n        ? changes[i].exception.replace(/#/g, '\\\\b')\n        : undefined\n\n      if (context) {\n        // This needs to be added\n      }\n\n      if (exception) {\n        // This needs to be added\n      }\n\n      let rpfc\n      let rptc\n      let rpe\n      let reg\n      if (changes[i].context) {\n        rpfc = changes[i].context.replace('_', changes[i].changeFrom)\n        rptc = changes[i].context.replace('_', changes[i].changeTo)\n        if (changes[i].exception) {\n          rpe = changes[i].exception.replace('_', changes[i].changeFrom)\n          // If there is an exception, replace in every context match except when it matches the exception\n          reg = new RegExp(`${rpe}|(${rpfc})`, 'g')\n          newWord = newWord.replace(reg, rptc)\n        } else {\n          // If there are no exceptions, replace in every context match\n          reg = new RegExp(rpfc, 'g')\n          newWord = newWord.replace(reg, rptc)\n        }\n      } else {\n        // If there is no context, replace in every match\n        reg = new RegExp(changes[i].changeFrom, 'g')\n        newWord = newWord.replace(reg, changes[i].changeTo)\n      }\n    }\n\n    return newWord\n  }\n\n  // Build the results object array\n  getResults (cats, rules, changes, lexicon, rwOutput) {\n    const rwLexicon = this.rewriteLex(lexicon, rules)\n    const results = []\n\n    for (let i = 0; i < lexicon.length; i++) {\n      results.push({\n        input: lexicon[i],\n        output: this.applyChanges(cats, changes, rwLexicon[i])\n      })\n    }\n\n    // If 'rewrite on output' is selected, rewrite the results. Otherwise, just return the results as-is.\n    return rwOutput ? this.unrewriteLex(results, rules) : results\n  }\n\n  idDiff (data, results) {\n    const newResults = JSON.parse(JSON.stringify(results))\n\n    if (\n      data.results !== undefined &&\n      data.results.length &&\n      typeof data.results[0] !== 'string'\n    ) {\n      for (let i = 0; i < newResults.length; i++) {\n        newResults[i].diff =\n          newResults[i].input !== data.results[i].input ||\n          newResults[i].output !== data.results[i].output\n      }\n    } else {\n      for (let i = 0; i < newResults.length; i++) {\n        newResults[i].diff = true\n      }\n    }\n\n    return newResults\n  }\n\n  morph (data) {\n    const newData = JSON.parse(JSON.stringify(data))\n\n    // Process the input\n    const rewriteRules = this.splitRewriteRules(newData.rewriteRules)\n    const categories = this.splitCategories(newData.categories, rewriteRules)\n    const soundChanges = this.splitSoundChanges(\n      categories,\n      newData.soundChanges,\n      rewriteRules\n    )\n\n    // Return the errors if there are any\n    let allErrors = []\n    if (typeof categories[0] === 'string') {\n      allErrors = allErrors.concat(categories)\n    }\n    if (typeof rewriteRules[0] === 'string') {\n      allErrors = allErrors.concat(rewriteRules)\n    }\n    if (typeof soundChanges[0] === 'string') {\n      allErrors = allErrors.concat(soundChanges)\n    }\n    if (allErrors.length) {\n      return allErrors\n    }\n\n    const results = this.getResults(\n      categories,\n      rewriteRules,\n      soundChanges,\n      newData.lexicon,\n      newData.rewriteOutput\n    )\n\n    return this.idDiff(newData, results)\n  }\n}\n\nconst morphService = new MorphService()\n\nexport default morphService\n","// extracted by mini-css-extract-plugin\nexport default {\"section\":\"morph-module--section--1I-l1\",\"container\":\"morph-module--container--dNMnn\",\"dataInput\":\"morph-module--data-input--wRMgE\",\"textAreaSpacer\":\"morph-module--text-area-spacer--1nXYi\",\"inputSection\":\"morph-module--input-section--4Neqi\",\"outText\":\"morph-module--out-text--w6CnP\",\"different\":\"morph-module--different--16-UT\",\"changed\":\"morph-module--changed--3WLYm\"};","import React, { useState } from 'react'\nimport { graphql, useStaticQuery } from 'gatsby'\n\nimport Notice from '../../components/notice'\nimport Tool from '../../components/tool'\n\nimport MorphForm from '../../pageComponents/morph/morphForm'\nimport MorphResults from '../../pageComponents/morph/morphResults'\nimport morphService from '../../services/morphService'\n\nimport styles from './morph.module.sass'\n\nexport const pageQuery = graphql`\nquery MorphToolQuery {\n  site {\n    siteMetadata {\n      toolInfo {\n        morph {\n          title\n          link\n          description\n        }\n      }\n    }\n  }\n}\n`\n\nconst Morph = props => {\n  const toolInfo = props.data?.site?.siteMetadata?.toolInfo?.morph\n\n  // State\n\n  const [categories, setCategories] = useState(\n    morphService.getData().categories\n  )\n  const [rewriteRules, setRewriteRules] = useState(\n    morphService.getData().rewriteRules\n  )\n  const [soundChanges, setSoundChanges] = useState(\n    morphService.getData().soundChanges\n  )\n  const [lexicon, setLexicon] = useState(morphService.getData().lexicon)\n  const [outputFormat, setOutputFormat] = useState(\n    morphService.getData().outputFormat\n  )\n  const [showDiff, setShowDiff] = useState(morphService.getData().showDiff)\n  const [showChanges, setShowChanges] = useState(\n    morphService.getData().showChanges\n  )\n  const [ruleReport, setRuleReport] = useState(\n    morphService.getData().ruleReport\n  )\n  const [rewriteOutput, setRewriteOutput] = useState(\n    morphService.getData().rewriteOutput\n  )\n  const [results, setResults] = useState(morphService.getData().results)\n\n  // Functions\n\n  const onChange = e => {\n    // When an input field is changed, update state\n    const name = e.target.name\n    let val\n    if (e.target.type === 'textarea') {\n      // Split the textarea inputs by newlines\n      val = e.target.value.split('\\n')\n    } else {\n      // Just get the value of the input\n      val = e.target.value\n    }\n\n    switch (name) {\n      case 'categories':\n        setCategories(val)\n        break\n      case 'rewriteRules':\n        setRewriteRules(val)\n        break\n      case 'soundChanges':\n        setSoundChanges(val)\n        break\n      case 'lexicon':\n        setLexicon(val)\n        break\n      case 'outputFormat':\n        setOutputFormat(val)\n        break\n      default:\n    }\n  }\n\n  const onCheck = e => {\n    // When a checkbox option is changed, update state\n    const val = e.target.value\n    const checked = e.target.checked\n    switch (val) {\n      case 'showChanges':\n        setShowChanges(checked)\n        break\n      case 'showDiff':\n        setShowDiff(checked)\n        break\n      case 'ruleReport':\n        setRuleReport(checked)\n        break\n      case 'rewriteOutput':\n        setRewriteOutput(checked)\n        break\n      default:\n    }\n  }\n\n  const onMorph = e => {\n    e.preventDefault()\n    const state = {\n      categories,\n      rewriteRules,\n      soundChanges,\n      lexicon,\n      outputFormat,\n      showDiff,\n      showChanges,\n      ruleReport,\n      rewriteOutput,\n      results\n    }\n    // Generate the output\n    setResults(morphService.morph(state))\n    // Save the current state to storage\n    morphService.setStorage(state)\n  }\n\n  const onSave = e => {\n    e.preventDefault()\n    const state = {\n      categories,\n      rewriteRules,\n      soundChanges,\n      lexicon,\n      outputFormat,\n      showDiff,\n      showChanges,\n      ruleReport,\n      rewriteOutput,\n      results\n    }\n    // Save the current state to storage and generate a file\n    morphService.save(state)\n  }\n\n  const onOpen = e => {\n    e.preventDefault()\n    const file = e.target.files[0]\n    const updateState = response => {\n      // Only change state if the file was successfully opened\n      if (response) {\n        setCategories(response.categories)\n        setRewriteRules(response.rewriteRules)\n        setSoundChanges(response.soundChanges)\n        setLexicon(response.lexicon)\n        setOutputFormat(response.outputFormat)\n        setShowDiff(response.showDiff)\n        setShowChanges(response.showChanges)\n        setRuleReport(response.ruleReport)\n        setRewriteOutput(response.rewriteOutput)\n        setResults(response.results)\n      }\n    }\n\n    morphService.open(file, updateState)\n  }\n\n  return (\n    <Tool toolInfo={toolInfo}>\n      <Notice>This tool is still in development.</Notice>\n      <MorphForm\n        styles={styles}\n        data={{\n          categories,\n          rewriteRules,\n          soundChanges,\n          lexicon,\n          outputFormat,\n          showDiff,\n          showChanges,\n          ruleReport,\n          rewriteOutput\n        }}\n        change={onChange}\n        morph={onMorph}\n        check={onCheck}\n        save={onSave}\n        open={onOpen}\n      />\n      <MorphResults\n        styles={styles}\n        outputFormat={outputFormat}\n        results={results}\n        showDiff={showDiff}\n        showChanges={showChanges}\n      />\n    </Tool>\n  )\n}\n\nexport default Morph\n"],"sourceRoot":""}