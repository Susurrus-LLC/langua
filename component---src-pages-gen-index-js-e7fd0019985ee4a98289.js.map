{"version":3,"sources":["webpack://langua/./src/pageComponents/gen/genForm.js","webpack://langua/./src/pageComponents/gen/genResults.js","webpack://langua/./src/services/genService.js","webpack://langua/./src/pages/gen/gen.module.sass","webpack://langua/./src/pages/gen/index.js"],"names":["styles","data","change","filePicker","React","selectOptions","vars","variab","index","key","value","subpatternRows","subpatterns","map","subpattern","className","subpsRow","id","name","selected","onChange","select","type","subpatternInput","clearButton","onClick","ver","small","classNames","sharedStyles","length","addingRow","addButton","pattern","patternInput","addedClasses","side","htmlFor","min","max","wordsInput","words","checked","newline","filterdupes","e","preventDefault","current","click","ref","filterResults","joinedResults","filterDupes","status","results","stats","toLocaleString","maxWords","filteredWords","filtered","remainingWords","remaining","output","includes","error","Array","from","Set","prototype","join","call","trim","outText","this","item","getData","bind","setStorage","save","open","changeSelect","changeSubpattern","clear","add","changePattern","wordNumChange","changeNewline","changeDupes","checkErrors","generate","build","dataProcessor","fileProcessor","file","callback","response","window","FileReader","result","endsWith","SubpatternSchema","schema","String","DataSchema","of","Number","Boolean","content","JSON","parse","parseInt","toast","autoClose","bodyClassName","progressClassName","console","errors","val","newData","stringify","splice","toUse","i","used","j","push","idDeps","deps","checkCirc","refed","sp","getSp","circ","duplicates","dupes","defed","undefed","undefSet","undefs","chooseRand","Math","floor","random","resolveVar","letter","getSubpattern","selection","resolveOpt","option","letters","test","split","pattArr","word","patt","count","optCount","addCount","multCount","k","props","toolInfo","site","siteMetadata","gen","useState","genService","setSubpatterns","setPattern","setWords","setNewline","setFilterdupes","setStatus","setResults","setStats","newdata","target","tagName","slice","files","which"],"mappings":"mQAiMA,EAnLgB,SAAC,GAA8B,IAA5BA,EAA2B,EAA3BA,OAAQC,EAAmB,EAAnBA,KAAMC,EAAa,EAAbA,OACzBC,EAAaC,cAEbC,EAAgBC,SAAS,SAACC,EAAQC,GAAT,OAC7B,0BAAQC,IAAKD,EAAOE,MAAOH,GACxBA,MAICI,EAAiBV,EAAKW,YAAYC,KAAI,SAACC,EAAYN,GAAb,OAC1C,uBAAKC,IAAKD,EAAOO,UAAWf,EAAOgB,UACjC,0BACEC,GAAE,IAAMT,EACRU,KAAI,IAAMV,EACVE,MAAOI,EAAWK,SAClBC,SAAUlB,EACVa,UAAWf,EAAOqB,OAClB,6CAA4Cb,GAE3CH,GAEH,yBACEiB,KAAK,OACLL,GAAE,IAAMT,EACRU,KAAI,IAAMV,EACVO,UAAWf,EAAOuB,gBAClBb,MAAOI,EAAWA,WAClBM,SAAUlB,EACV,2BAA0BM,IAE5B,uBAAKO,UAAWf,EAAOwB,aACrB,gBAAC,IAAD,CACEP,GAAE,IAAMT,EACRiB,QAASvB,EACTwB,IAAI,SACJC,OAAK,EACLL,KAAK,SACL,kCAAiCd,GANnC,eAuCN,OACE,gBAAC,IAAD,CAAMU,KAAK,YACT,uBAAKH,UAAWa,IAAW5B,EAAOY,YAAaiB,WAC7C,sBAAId,UAAWc,kBAAf,eACClB,EA7BW,WAChB,GAAIV,EAAKW,YAAYkB,OAASxB,WAC5B,OACE,uBAAKS,UAAWf,EAAO+B,WACrB,gBAAC,IAAD,CACEN,QAASvB,EACTe,GAAG,MACHS,IAAI,UACJC,OAAK,EACLL,KAAK,SACL,aAAW,wBANb,QA0BDU,IAEH,uBAAKjB,UAAWa,IAAW5B,EAAOiC,QAASJ,WACzC,sBAAId,UAAWc,kBAAf,WACA,yBACEP,KAAK,OACLL,GAAG,UACHC,KAAK,UACLH,UAAWf,EAAOkC,aAClBxB,MAAOT,EAAKgC,QACZb,SAAUlB,EACV,aAAW,aAGf,gBAAC,IAAD,CAASiC,aAAcN,UACrB,gBAAC,IAAD,CAAaO,KAAK,QAChB,gBAAC,IAAD,KACE,gBAAC,IAAD,CAAQnB,GAAG,WAAWQ,QAASvB,EAAQoB,KAAK,SAASI,IAAI,WAAzD,aAIF,gBAAC,IAAD,KACE,yBAAOW,QAAQ,SAAf,UACA,yBACEf,KAAK,SACLL,GAAG,QACHC,KAAK,QACLoB,IAAI,IACJC,IAAI,OACJxB,UAAWf,EAAOwC,WAClB9B,MAAOT,EAAKwC,MACZrB,SAAUlB,EACV,aAAW,iCAGf,gBAAC,IAAD,KACE,6BACE,yBACEoB,KAAK,WACLL,GAAG,UACHC,KAAK,UACLR,MAAM,UACNgC,QAASzC,EAAK0C,QACdvB,SAAUlB,IACT,IARL,kBAYF,gBAAC,IAAD,KACE,6BACE,yBACEoB,KAAK,WACLL,GAAG,cACHC,KAAK,UACLR,MAAM,cACNgC,QAASzC,EAAK2C,YACdxB,SAAUlB,IACT,IARL,uBAaJ,gBAAC,IAAD,CAAakC,KAAK,SAChB,gBAAC,IAAD,KACE,gBAAC,IAAD,CAAQnB,GAAG,OAAOS,IAAI,UAAUD,QAASvB,EAAQoB,KAAK,UAAtD,SAIF,gBAAC,IAAD,KACE,gBAAC,IAAD,CAAQL,GAAG,OAAOQ,QAhFH,SAAAoB,GACvBA,EAAEC,iBACF3C,EAAW4C,QAAQrC,MAAQ,GAC3BP,EAAW4C,QAAQC,SA6EkC1B,KAAK,UAAlD,QAGA,yBACEL,GAAG,OACHC,KAAK,OACLH,UAAWc,WACXP,KAAK,OACL2B,IAAK9C,EACLiB,SAAUlB,S,oBC3FxB,EArEmB,SAAC,GAOb,IAOGgD,EACAC,EAdRnD,EAMI,EANJA,OACA2C,EAKI,EALJA,QACAS,EAII,EAJJA,YACAC,EAGI,EAHJA,OACAC,EAEI,EAFJA,QACAC,EACI,EADJA,MAEMd,EAAQc,EAAMd,MAAMe,iBACpBC,EAAWF,EAAME,SAASD,iBAC1BE,EAAgBH,EAAMI,SAASH,iBAC/BI,EAAiBL,EAAMM,UAAUL,iBA+BvC,OACE,gBAAC,IAAD,KACE,uBAAKzC,UAAWf,EAAO8D,QArBrBT,EAAOU,SAAS,MACX,KAEAV,EAAOxC,KAAI,SAACmD,EAAOxD,GAAR,OAChB,qBAAGC,IAAKD,EAAOO,UAAWc,WACvBmC,OAdDd,EAAgBE,EAAca,MAAMC,KAAK,IAAIC,IAAIb,IAAYA,EAC7DH,EAAgBc,MAAMG,UAAUC,KACnCC,KAAKpB,EAAkBP,EAAU,KAAO,KACxC4B,OAEI,qBAAGxD,UAAWf,EAAOwE,SAAUrB,KA6BpC,uBAAKpC,UAAWc,WACd,qBAAGd,UAAWc,eAdduB,EACI,UAAWQ,EAAjB,KAAoCF,EAApC,4CAA6FD,EAEvF,UAAWhB,EAAjB,8BAAoDgB,M,gDC0d1D,EAFmB,I,WA5fjB,aACEgB,KAAKC,KAAO,MACZD,KAAKE,QAAUF,KAAKE,QAAQC,KAAKH,MACjCA,KAAKI,WAAaJ,KAAKI,WAAWD,KAAKH,MACvCA,KAAKK,KAAOL,KAAKK,KAAKF,KAAKH,MAC3BA,KAAKM,KAAON,KAAKM,KAAKH,KAAKH,MAC3BA,KAAKO,aAAeP,KAAKO,aAAaJ,KAAKH,MAC3CA,KAAKQ,iBAAmBR,KAAKQ,iBAAiBL,KAAKH,MACnDA,KAAKS,MAAQT,KAAKS,MAAMN,KAAKH,MAC7BA,KAAKU,IAAMV,KAAKU,IAAIP,KAAKH,MACzBA,KAAKW,cAAgBX,KAAKW,cAAcR,KAAKH,MAC7CA,KAAKY,cAAgBZ,KAAKY,cAAcT,KAAKH,MAC7CA,KAAKa,cAAgBb,KAAKa,cAAcV,KAAKH,MAC7CA,KAAKc,YAAcd,KAAKc,YAAYX,KAAKH,MACzCA,KAAKe,YAAcf,KAAKe,YAAYZ,KAAKH,MACzCA,KAAKgB,SAAWhB,KAAKgB,SAASb,KAAKH,MACnCA,KAAKiB,MAAQjB,KAAKiB,MAAMd,KAAKH,M,2BAI/BE,QAAA,WACE,OAAOgB,YAAsBlB,KAAKC,O,EAIpCG,WAAA,SAAY5E,GACV0F,eAAyB1F,EAAMwE,KAAKC,O,EAItCI,KAAA,SAAM7E,GACJ2F,SAAmB3F,EAAMwE,KAAKC,O,EAIhCK,KAAA,SAAMc,EAAMC,GAAW,IACjBC,EADgB,OAiEhBC,OAAOC,WAETL,aAAuBC,GAhEF,SAAAK,GAErB,GAAIL,EAAK3E,KAAKiF,SAASP,aAAuB,EAAKlB,OAAQ,CAEzD,IAAM0B,EAAmBC,IAAO,CAC9BlF,SAAU,QACVL,WAAYwF,SAGRC,EAAaF,IAAO,CACxBzF,YAAaqD,MAAMuC,GAAG,EAAG,GAAIJ,GAC7BnE,QAASqE,OACT7D,MAAOgE,OAAOnE,IAAI,GAAGC,IAAI,MACzBI,QAAS+D,QACT9D,YAAa8D,UAGTC,EAAUC,KAAKC,MAAMX,GAE3BS,EAAQlE,MAAQqE,SAASH,EAAQlE,MAAO,IAEpC8D,EAAWI,IAEbI,aAAA,oBAAkClB,EAAK3E,KAAvC,IAAgD,CAC9C8F,UAAW,IACXjG,UAAW,eACXkG,cAAe,oBACfC,kBAAmB,0BAGrB,EAAKrC,WAAW8B,GAEhBZ,EAAWY,IAGXI,UAAA,kBAA6BlB,EAAK3E,KAAlC,eAAsD,CACpD8F,UAAW,IACXjG,UAAW,iBACXkG,cAAe,sBACfC,kBAAmB,4BAIrBC,QAAQnD,MAAMuC,EAAWa,OAAOT,IAEhCZ,GAAW,QAIbgB,UAAW,2BAA4B,CACrCC,UAAW,IACXjG,UAAW,iBACXkG,cAAe,sBACfC,kBAAmB,4BAGrBnB,GAAW,EAGbD,EAASC,OAQTgB,UAAW,wCAAyC,CAClDC,UAAW,IACXjG,UAAW,iBACXkG,cAAe,sBACfC,kBAAmB,4BAIrBpB,EADAC,GAAW,K,EAMff,aAAA,SAAc/D,EAAIoG,EAAKpH,GACrB,IAAMqH,EAAUV,KAAKC,MAAMD,KAAKW,UAAUtH,IAE1C,OADAqH,EAAQ1G,YAAYK,GAAIE,SAAWkG,EAC5BC,G,EAITrC,iBAAA,SAAkBhE,EAAIoG,EAAKpH,GACzB,IAAMqH,EAAUV,KAAKC,MAAMD,KAAKW,UAAUtH,IAE1C,OADAqH,EAAQ1G,YAAYK,GAAIH,WAAauG,EAC9BC,G,EAITpC,MAAA,SAAOjE,EAAIhB,GACT,IAAMqH,EAAUV,KAAKC,MAAMD,KAAKW,UAAUtH,IAE1C,OADAqH,EAAQ1G,YAAY4G,OAAOvG,EAAI,GACxBqG,G,EAITnC,IAAA,SAAKlF,GAKH,IAJA,IAAIwH,EAAQ,GACNH,EAAUV,KAAKC,MAAMD,KAAKW,UAAUtH,IAGjCyH,EAAI,EAAGA,EAAIpH,WAAaoH,IAAK,CAEpC,IADA,IAAIC,GAAO,EACFC,EAAI,EAAGA,EAAIN,EAAQ1G,YAAYkB,OAAQ8F,IAC9C,GAAIN,EAAQ1G,YAAYgH,GAAGzG,WAAab,IAAKoH,GAAI,CAC/CC,GAAO,EACP,MAKJ,IAAKA,EAAL,CACEF,EAAQnH,IAAKoH,GACb,OAUJ,OAJIJ,EAAQ1G,YAAYkB,OAASxB,YAC/BgH,EAAQ1G,YAAYiH,KAAK,CAAE1G,SAAUsG,EAAO3G,WAAY,KAGnDwG,G,EAITlC,cAAA,SAAeiC,EAAKpH,GAClB,IAAMqH,EAAUV,KAAKC,MAAMD,KAAKW,UAAUtH,IAE1C,OADAqH,EAAQrF,QAAUoF,EACXC,G,EAITjC,cAAA,SAAegC,EAAKpH,GASlB,GAPIoH,EAAM,EACRA,EAAM,EACGA,EAAM,OACfA,EAAM,MAIJA,EAAM,GAAKA,EAAM,IAAO,CAC1B,IAAMC,EAAUV,KAAKC,MAAMD,KAAKW,UAAUtH,IAE1C,OADAqH,EAAQ7E,MAAQ4E,EACTC,EAGP,OAAO,G,EAKXhC,cAAA,SAAe5C,EAASzC,GACtB,IAAMqH,EAAUV,KAAKC,MAAMD,KAAKW,UAAUtH,IAE1C,OADAqH,EAAQ3E,QAAUD,EACX4E,G,EAIT/B,YAAA,SAAa7C,EAASzC,GACpB,IAAMqH,EAAUV,KAAKC,MAAMD,KAAKW,UAAUtH,IAE1C,OADAqH,EAAQ1E,YAAcF,EACf4E,G,EAIT9B,YAAA,SAAavF,GA8CX,IA7CA,IAAIoD,EAAS,GAcPyE,EAAS,SAAAhH,GAEb,IADA,IAAMiH,EAAO,GACJL,EAAI,EAAGA,EAAI5G,EAAWgB,OAAQ4F,IACjCpH,aAAcQ,EAAW4G,KAC3BK,EAAKF,KAAK/G,EAAW4G,IAGzB,OAAOzD,MAAMC,KAAK,IAAIC,IAAI4D,KAGtBC,EAAY,SAAZA,EAAa7G,EAAU8G,GAC3B,IAAMC,EAtBM,SAAA/G,GAEZ,IADA,IAAI+G,EAAK,GACAR,EAAI,EAAGA,EAAIzH,EAAKW,YAAYkB,OAAQ4F,IAC3C,GAAIzH,EAAKW,YAAY8G,GAAGvG,WAAaA,EAAU,CAC7C+G,EAAKjI,EAAKW,YAAY8G,GAAG5G,WACzB,MAGJ,OAAOoH,EAcIC,CAAMhH,GACX4G,EAAOD,EAAOI,GAChBE,GAAO,EAEX,GAAIL,EAAKjG,OAAS,EAChB,GAAIiG,EAAKhE,SAAS5C,IAAa8G,EAAMlE,SAAS5C,GAC5CiH,GAAO,MACF,CACL,IAAIV,EAAI,EAER,IADAO,EAAMJ,KAAK1G,IACHiH,GAAQV,EAAIK,EAAKjG,QACvBsG,EAAOJ,EAAUD,EAAKL,GAAIO,GAC1BP,IAKN,OAAOU,GAGAV,EAAI,EAAGA,EAAIzH,EAAKW,YAAYkB,OAAQ4F,IAAK,CAChD,IAAMK,EAAOD,EAAO7H,EAAKW,YAAY8G,GAAG5G,YAClCmH,EAAQ,GAEd,GAAIF,EAAKjG,OAAS,EAChB,IAAK,IAAI8F,EAAI,EAAGA,EAAIG,EAAKjG,OAAQ8F,IAC/B,GAAII,EAAUD,EAAKH,GAAIK,GAAQ,CAC7B5E,EAAOwE,KAAK,iDACZ,OAQR,IADA,IAAIQ,EAAa,GACRX,EAAI,EAAGA,EAAIzH,EAAKW,YAAYkB,OAAQ4F,IAG3C,IAFA,IAAM3E,EAAU9C,EAAKW,YAAY8G,GAAGvG,SAE3ByG,EAAI,EAAGA,EAAI3H,EAAKW,YAAYkB,OAAQ8F,IACvCF,IAAME,GAGJ3H,EAAKW,YAAYgH,GAAGzG,WAAa4B,GACnCsF,EAAWR,KAAK9E,GAOxB,IAAMuF,GADND,EAAapE,MAAMC,KAAK,IAAIC,IAAIkE,KACPhE,KAAK,MAE1BgE,EAAWvG,OAAS,EACtBuB,EAAOwE,KAAP,8BACgCS,EADhC,oCAG+B,IAAtBD,EAAWvG,QACpBuB,EAAOwE,KAAP,2BAC6BS,EAD7B,kCAOF,IADA,IAAMC,EAAQ,GACLb,EAAI,EAAGA,EAAIzH,EAAKW,YAAYkB,OAAQ4F,IAC3Ca,EAAMV,KAAK5H,EAAKW,YAAY8G,GAAGvG,UAIjC,IADA,IAAMqH,EAAU,GACPd,EAAI,EAAGA,EAAIzH,EAAKgC,QAAQH,OAAQ4F,IACnCpH,aAAcL,EAAKgC,QAAQyF,MACxBa,EAAMxE,SAAS9D,EAAKgC,QAAQyF,KAC/Bc,EAAQX,KAAK5H,EAAKgC,QAAQyF,KAIhC,IAAK,IAAIA,EAAI,EAAGA,EAAIzH,EAAKW,YAAYkB,OAAQ4F,IAC3C,IAAK,IAAIE,EAAI,EAAGA,EAAI3H,EAAKW,YAAY8G,GAAG5G,WAAWgB,OAAQ8F,IACrDtH,aAAcL,EAAKW,YAAY8G,GAAG5G,WAAW8G,MAC1CW,EAAMxE,SAAS9D,EAAKW,YAAY8G,GAAG5G,WAAW8G,KACjDY,EAAQX,KAAK5H,EAAKW,YAAY8G,GAAG5G,WAAW8G,KAMpD,IAAMa,EAAWxE,MAAMC,KAAK,IAAIC,IAAIqE,IAC9BE,EAASD,EAASpE,KAAK,MAc7B,OAZIoE,EAAS3G,OAAS,EAEpBuB,EAAOwE,KAAP,6BAC+Ba,EAD/B,qLAG6B,IAApBD,EAAS3G,QAClBuB,EAAOwE,KAAP,sBACwBa,EADxB,kLAKFrF,EAASY,MAAMC,KAAK,IAAIC,IAAId,K,EAK9BoC,SAAA,SAAUxF,GACR,IAAMoD,EAASoB,KAAKe,YAAYvF,GAkBhC,OAfIoD,EAAOvB,OAAS,EACR,CACRuB,OAAQA,EACRC,QAAS,GACTC,MAAO,CACLd,MAAO,EACPgB,SAAU,EACVE,SAAU,EACVE,UAAW,IAILY,KAAKiB,MAAMzF,EAAM,CAAC,Q,EAOhCyF,MAAA,SAAOzF,EAAMoD,GAuDX,IAtDA,IAAMC,EAAU,GACVgE,EAAUV,KAAKC,MAAMD,KAAKW,UAAUtH,IAGpC0I,EAAa,SAAA7G,GACjB,OAAO8G,KAAKC,MAAMD,KAAKE,SAAWhH,IAgB9BiH,EAAa,SAAbA,EAAcnI,EAAaO,GAC/B,IAAI6H,EAAS,GACb,GAAI1I,aAAca,GAAW,CAC3B,IAAML,EAfY,SAACF,EAAaO,GAElC,IADA,IAAIL,EAAa,GACR4G,EAAI,EAAGA,EAAI9G,EAAYkB,OAAQ4F,IACtC,GAAI9G,EAAY8G,GAAGvG,WAAaA,EAAU,CACxCL,EAAaF,EAAY8G,GAAG5G,WAC5B,MAGJ,OAAOA,EAOcmI,CAAcrI,EAAaO,GACxC+H,EAAYpI,EAAW6H,EAAW7H,EAAWgB,SAEjDkH,EADE1I,aAAc4I,GACPH,EAAWnI,EAAasI,GAExBA,OAGXF,EAAS7H,EAKX,OAHI6H,EAAOlH,OAAS,IAClBkH,EAASG,EAAWvI,EAAaoI,IAE5BA,GAGHG,EAAa,SAACvI,EAAawI,GAE/B,IADA,IAAIC,EAAU,GACL3B,EAAI,EAAGA,EAAI0B,EAAOtH,OAAQ4F,IAC7B,aAAa4B,KAAKF,EAAO1B,MAI3B2B,GAAWN,EAAWnI,EAAawI,EAAO1B,KAG9C,OAAO2B,GAIA3B,EAAI,EAAGA,EAAIJ,EAAQ1G,YAAYkB,OAAQ4F,IAC9CJ,EAAQ1G,YAAY8G,GAAG5G,WAAawG,EAAQ1G,YAC1C8G,GACA5G,WAAWyI,MAAM,KAOrB,IAHA,IAAMC,EAAUlC,EAAQrF,QAAQsH,MAAM,KAG7B7B,EAAI,EAAGA,EAAIJ,EAAQ7E,MAAOiF,IAAK,CACtC,IAAI+B,EAAO,GAGLC,EAAOF,EAAQb,EAAWa,EAAQ1H,SAExC2H,GAAQN,EAAW7B,EAAQ1G,YAAa8I,GAExCpG,EAAQuE,KAAK4B,GAQf,IAFA,IAAIE,EAAQ,EAEHjC,EAAI,EAAGA,EAAI8B,EAAQ1H,OAAQ4F,IAAK,CACvC,IAAIkC,EAAW,EACf,GAA0B,IAAtBJ,EAAQ9B,GAAG5F,OAAc,CAC3B8H,EAAW,EACX,MAEA,IAAK,IAAIhC,EAAI,EAAGA,EAAI4B,EAAQ9B,GAAG5F,OAAQ8F,IAAK,CAC1C,IAAMrH,EAASiJ,EAAQ9B,GAAGE,GACtBiC,EAAW,EACXC,EAAY,EAChB,IAAI,aAAaR,KAAK/I,GAAtB,CAGO,GAAKD,aAAcC,GAIxB,IAAK,IAAIwJ,EAAI,EAAGA,EAAIzC,EAAQ1G,YAAYkB,OAAQiI,IAAK,CACnD,IAAMjJ,EAAawG,EAAQ1G,YAAYmJ,GACvC,GAAIjJ,EAAWK,WAAaZ,EAAQ,CAElCuJ,GAAahJ,EAAWA,WAAWgB,OACnC,YAPJ+H,GAAY,EAcdD,GAAYE,EACZF,GAAYC,GAGhBF,GAASC,EAIX,IAAInH,EAAQ,EACc,IAAtBa,EAAQ,GAAGxB,SACbW,EAAQa,EAAQxB,QAGlB,IACM+B,EADgBI,MAAMC,KAAK,IAAIC,IAAIb,IACTxB,OAchC,MAXiB,CACfuB,OAAQA,EACRC,QAASA,EACTC,MAAO,CACLd,MAAOA,EACPgB,SAAUkG,EACVhG,SARa2D,EAAQ7E,MAAQoB,EAS7BA,UAAWA,K,MC5fnB,GAAgB,UAAY,+BAA+B,SAAW,+BAA+B,UAAY,gCAAgC,aAAe,mCAAmC,gBAAkB,sCAAsC,WAAa,iCAAiC,QAAU,+BCgKnT,EAtIY,SAAAmG,GAAU,IAAD,QACbC,EAAQ,UAAGD,EAAM/J,YAAT,iBAAG,EAAYiK,YAAf,iBAAG,EAAkBC,oBAArB,iBAAG,EAAgCF,gBAAnC,aAAG,EAA0CG,IAI3D,GAAsCC,cACpCC,YAAqB1J,aADhBA,EAAP,KAAoB2J,EAApB,KAGA,GAA8BF,cAASC,YAAqBrI,SAArDA,EAAP,KAAgBuI,EAAhB,KACA,GAA0BH,cAASC,YAAqB7H,OAAjDA,EAAP,KAAcgI,EAAd,KACA,GAA8BJ,cAASC,YAAqB3H,SAArDA,EAAP,KAAgB+H,EAAhB,KACA,GAAsCL,cACpCC,YAAqB1H,aADhBA,EAAP,KAAoB+H,EAApB,KAGA,GAA4BN,cAAS,CAAC,OAA/BhH,EAAP,KAAeuH,EAAf,KACA,GAA8BP,cAAS,CAAC,KAAjC/G,EAAP,KAAgBuH,EAAhB,KACA,GAA0BR,cAAS,CACjC5H,MAAO,EACPgB,SAAU,EACVE,SAAU,EACVE,UAAW,IAJNN,EAAP,KAAcuH,EAAd,KA6FA,OACE,gBAAC,IAAD,CAAMb,SAAUA,GACd,gBAAC,EAAD,CACEjK,OAAQA,EACRC,KAAM,CACJW,cACAqB,UACAQ,QACAE,UACAC,eAEF1C,OA/FgB,SAAA2C,GACpB,IAAMkI,EAAU,CACdnK,cACAqB,UACAQ,QACAE,UACAC,eAGF,GAAyB,WAArBC,EAAEmI,OAAOC,SAEX,GADApI,EAAEC,iBACoB,WAAlBD,EAAEmI,OAAO1J,KAAmB,CAE9B,IAAMyE,EAAWuE,WAAoBS,GACrCH,EAAU7E,EAAS1C,QACnBwH,EAAW9E,EAASzC,SACpBwH,EAAS/E,EAASxC,OAElB+G,aAAsBS,QACjB,GAAsB,WAAlBlI,EAAEmI,OAAO1J,KAClB,GAAoB,SAAhBuB,EAAEmI,OAAO/J,GAEXqJ,OAAgBS,QACX,GAAoB,QAAhBlI,EAAEmI,OAAO/J,GAElBsJ,EAAeD,MAAeS,GAASnK,kBAClC,GAAgC,MAA5BiC,EAAEmI,OAAO/J,GAAGiK,MAAM,EAAG,GAAY,CAE1C,IAAMjK,EAAK4B,EAAEmI,OAAO/J,GAAGiK,MAAM,GAC7BX,EAAeD,QAAiBrJ,EAAI8J,GAASnK,mBAG5C,GAAsB,SAAlBiC,EAAEmI,OAAO1J,KAAiB,CACnCuB,EAAEC,iBAEF,IAAM+C,EAAOhD,EAAEmI,OAAOG,MAAM,GAW5Bb,OAAgBzE,GAVI,SAAAE,GACdA,IAEFwE,EAAexE,EAASnF,aACxB4J,EAAWzE,EAAS9D,SACpBwI,EAAS1E,EAAStD,OAClBiI,EAAW3E,EAASpD,SACpBgI,EAAe5E,EAASnD,sBAIvB,GAAsB,aAAlBC,EAAEmI,OAAO1J,KAAqB,CACvC,IAAMoB,EAAUG,EAAEmI,OAAOtI,QACL,YAAhBG,EAAEmI,OAAO/J,GAEXyJ,EAAWJ,gBAAyB5H,EAASqI,GAASpI,SAC7B,gBAAhBE,EAAEmI,OAAO/J,IAElB0J,EAAeL,cAAuB5H,EAASqI,GAASnI,iBAErD,CACL,IAAMyE,EAAMxE,EAAEmI,OAAOtK,MACrB,GAAoB,YAAhBmC,EAAEmI,OAAO/J,GAEXuJ,EAAWF,gBAAyBjD,EAAK0D,GAAS9I,cAC7C,GAAoB,UAAhBY,EAAEmI,OAAO/J,GAAgB,CAElC,IAAM8E,EAAWuE,gBAAyBjD,EAAK0D,GAC3ChF,GAEF0E,EAAS1E,EAAStD,WAEf,CACL,IAAMxB,EAAK4B,EAAEmI,OAAO/J,GAAGiK,MAAM,GACvBE,EAAQvI,EAAEmI,OAAO/J,GAAGiK,MAAM,EAAG,GACrB,MAAVE,EAEFb,EAAeD,eAAwBrJ,EAAIoG,EAAK0D,GAASnK,aACtC,MAAVwK,GAETb,EACED,mBAA4BrJ,EAAIoG,EAAK0D,GAASnK,kBAoBpD,gBAAC,EAAD,CACEZ,OAAQA,EACR2C,QAASA,EACTS,YAAaR,EACbS,OAAQA,EACRC,QAASA,EACTC,MAAOA","file":"component---src-pages-gen-index-js-e7fd0019985ee4a98289.js","sourcesContent":["import React from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Form from '../../components/form'\nimport Button from '../../components/button'\nimport Control from '../../components/control'\nimport ControlSide from '../../components/control/side'\nimport ControlPiece from '../../components/control/piece'\n\nimport sharedStyles from '../../components/form/sharedForm.module.sass'\n\nimport { vars } from '../../data/gen'\n\nconst GenForm = ({ styles, data, change }) => {\n  const filePicker = React.createRef()\n\n  const selectOptions = vars.map((variab, index) => (\n    <option key={index} value={variab}>\n      {variab}\n    </option>\n  ))\n\n  const subpatternRows = data.subpatterns.map((subpattern, index) => (\n    <div key={index} className={styles.subpsRow}>\n      <select\n        id={`v${index}`}\n        name={`v${index}`}\n        value={subpattern.selected}\n        onChange={change}\n        className={styles.select}\n        aria-label={`Variable name for subpattern ${index}`}\n      >\n        {selectOptions}\n      </select>\n      <input\n        type='text'\n        id={`p${index}`}\n        name={`p${index}`}\n        className={styles.subpatternInput}\n        value={subpattern.subpattern}\n        onChange={change}\n        aria-label={`Subpattern ${index}`}\n      />\n      <div className={styles.clearButton}>\n        <Button\n          id={`c${index}`}\n          onClick={change}\n          ver='danger'\n          small\n          type='button'\n          aria-label={`Delete subpattern ${index}`}\n        >\n          Delete\n        </Button>\n      </div>\n    </div>\n  ))\n\n  const addButton = () => {\n    if (data.subpatterns.length < vars.length) {\n      return (\n        <div className={styles.addingRow}>\n          <Button\n            onClick={change}\n            id='add'\n            ver='success'\n            small\n            type='button'\n            aria-label='Add a new subpattern'\n          >\n            Add\n          </Button>\n        </div>\n      )\n    }\n  }\n\n  const invokeFilePicker = e => {\n    e.preventDefault()\n    filePicker.current.value = ''\n    filePicker.current.click()\n  }\n\n  return (\n    <Form name='gen-form'>\n      <div className={classNames(styles.subpatterns, sharedStyles.part)}>\n        <h5 className={sharedStyles.sectionTitle}>Subpatterns</h5>\n        {subpatternRows}\n        {addButton()}\n      </div>\n      <div className={classNames(styles.pattern, sharedStyles.part)}>\n        <h5 className={sharedStyles.sectionTitle}>Pattern</h5>\n        <input\n          type='text'\n          id='pattern'\n          name='pattern'\n          className={styles.patternInput}\n          value={data.pattern}\n          onChange={change}\n          aria-label='Pattern'\n        />\n      </div>\n      <Control addedClasses={sharedStyles.part}>\n        <ControlSide side='left'>\n          <ControlPiece>\n            <Button id='generate' onClick={change} type='submit' ver='neutral'>\n              Generate\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <label htmlFor='words'>words:</label>\n            <input\n              type='number'\n              id='words'\n              name='words'\n              min='1'\n              max='9999'\n              className={styles.wordsInput}\n              value={data.words}\n              onChange={change}\n              aria-label='Number of words to generate'\n            />\n          </ControlPiece>\n          <ControlPiece>\n            <label>\n              <input\n                type='checkbox'\n                id='newline'\n                name='options'\n                value='newline'\n                checked={data.newline}\n                onChange={change}\n              />{' '}\n              new line each\n            </label>\n          </ControlPiece>\n          <ControlPiece>\n            <label>\n              <input\n                type='checkbox'\n                id='filterdupes'\n                name='options'\n                value='filterdupes'\n                checked={data.filterdupes}\n                onChange={change}\n              />{' '}\n              filter duplicates\n            </label>\n          </ControlPiece>\n        </ControlSide>\n        <ControlSide side='right'>\n          <ControlPiece>\n            <Button id='save' ver='success' onClick={change} type='button'>\n              Save\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <Button id='open' onClick={invokeFilePicker} type='button'>\n              Open\n            </Button>\n            <input\n              id='file'\n              name='file'\n              className={sharedStyles.hidden}\n              type='file'\n              ref={filePicker}\n              onChange={change}\n            />\n          </ControlPiece>\n        </ControlSide>\n      </Control>\n    </Form>\n  )\n}\n\nGenForm.propTypes = {\n  styles: PropTypes.object,\n  data: PropTypes.shape({\n    subpatterns: PropTypes.arrayOf(\n      PropTypes.shape({\n        selected: PropTypes.string.isRequired,\n        subpattern: PropTypes.string.isRequired\n      })\n    ).isRequired,\n    pattern: PropTypes.string.isRequired,\n    words: PropTypes.number.isRequired,\n    newline: PropTypes.bool.isRequired,\n    filterdupes: PropTypes.bool.isRequired\n  }).isRequired,\n  change: PropTypes.func.isRequired\n}\n\nexport default GenForm\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport Results from '../../components/results'\n\nimport sharedStyles from '../../components/results/sharedResults.module.sass'\n\nconst GenResults = ({\n  styles,\n  newline,\n  filterDupes,\n  status,\n  results,\n  stats\n}) => {\n  const words = stats.words.toLocaleString()\n  const maxWords = stats.maxWords.toLocaleString()\n  const filteredWords = stats.filtered.toLocaleString()\n  const remainingWords = stats.remaining.toLocaleString()\n\n  const outputText = () => {\n    const filterResults = filterDupes ? Array.from(new Set(results)) : results\n    const joinedResults = Array.prototype.join\n      .call(filterResults, `${newline ? '\\n' : ' '}`)\n      .trim()\n\n    return <p className={styles.outText}>{joinedResults}</p>\n  }\n\n  const errorText = () => {\n    if (status.includes('ok')) {\n      return null\n    } else {\n      return status.map((error, index) => (\n        <p key={index} className={sharedStyles.error}>\n          {error}\n        </p>\n      ))\n    }\n  }\n\n  const statsText = () => {\n    if (filterDupes) {\n      return `words: ${remainingWords} (${filteredWords} filtered out); maximum different words: ${maxWords}`\n    } else {\n      return `words: ${words}; maximum different words: ${maxWords}`\n    }\n  }\n\n  return (\n    <Results>\n      <div className={styles.output}>\n        {errorText()}\n        {outputText()}\n      </div>\n      <div className={sharedStyles.stats}>\n        <p className={sharedStyles.statsText}>{statsText()}</p>\n      </div>\n    </Results>\n  )\n}\n\nGenResults.propTypes = {\n  styles: PropTypes.object,\n  newline: PropTypes.bool.isRequired,\n  filterDupes: PropTypes.bool.isRequired,\n  status: PropTypes.arrayOf(PropTypes.string).isRequired,\n  results: PropTypes.arrayOf(PropTypes.string).isRequired,\n  stats: PropTypes.shape({\n    words: PropTypes.number.isRequired,\n    maxWords: PropTypes.number.isRequired,\n    filtered: PropTypes.number.isRequired,\n    remaining: PropTypes.number.isRequired\n  }).isRequired\n}\n\nexport default GenResults\n","import { toast } from 'react-toastify'\nimport schema from 'js-schema'\n\nimport dataProcessor from '../tools/dataProcessor'\nimport fileProcessor from '../tools/fileProcessor'\n\nimport { vars } from '../data/gen'\n\nclass GenService {\n  constructor () {\n    this.item = 'gen'\n    this.getData = this.getData.bind(this)\n    this.setStorage = this.setStorage.bind(this)\n    this.save = this.save.bind(this)\n    this.open = this.open.bind(this)\n    this.changeSelect = this.changeSelect.bind(this)\n    this.changeSubpattern = this.changeSubpattern.bind(this)\n    this.clear = this.clear.bind(this)\n    this.add = this.add.bind(this)\n    this.changePattern = this.changePattern.bind(this)\n    this.wordNumChange = this.wordNumChange.bind(this)\n    this.changeNewline = this.changeNewline.bind(this)\n    this.changeDupes = this.changeDupes.bind(this)\n    this.checkErrors = this.checkErrors.bind(this)\n    this.generate = this.generate.bind(this)\n    this.build = this.build.bind(this)\n  }\n\n  // Get the data from storage or from the default data\n  getData () {\n    return dataProcessor.getData(this.item)\n  }\n\n  // Store the current data in storage\n  setStorage (data) {\n    dataProcessor.setStorage(data, this.item)\n  }\n\n  // Save the current state to storage and generate a file\n  save (data) {\n    fileProcessor.save(data, this.item)\n  }\n\n  // Open a file and parse it to restore a saved state\n  open (file, callback) {\n    let response\n\n    const processResults = result => {\n      // If correct filetype\n      if (file.name.endsWith(fileProcessor.filetype(this.item))) {\n        // Define correct file structure\n        const SubpatternSchema = schema({\n          selected: /[A-Z]/,\n          subpattern: String\n        })\n\n        const DataSchema = schema({\n          subpatterns: Array.of(1, 24, SubpatternSchema),\n          pattern: String,\n          words: Number.min(1).max(9999),\n          newline: Boolean,\n          filterdupes: Boolean\n        })\n\n        const content = JSON.parse(result)\n\n        content.words = parseInt(content.words, 10)\n\n        if (DataSchema(content)) {\n          // If the file's content contains valid Data, load it\n          toast.success(`Data loaded from ${file.name}.`, {\n            autoClose: 5000,\n            className: 'toast-opened',\n            bodyClassName: 'toast-opened-body',\n            progressClassName: 'toast-opened-progress'\n          })\n\n          this.setStorage(content)\n\n          response = content\n        } else {\n          // If the file's content does not contain valid Data, show an error\n          toast.warn(`The content of ${file.name} is invalid.`, {\n            autoClose: 5000,\n            className: 'toast-unopened',\n            bodyClassName: 'toast-unopened-body',\n            progressClassName: 'toast-unopened-progress'\n          })\n\n          // eslint-disable-next-line\n          console.error(DataSchema.errors(content))\n\n          response = false\n        }\n      } else {\n        // If incorrect filetype\n        toast.warn('Wrong filetype selected.', {\n          autoClose: 5000,\n          className: 'toast-unopened',\n          bodyClassName: 'toast-unopened-body',\n          progressClassName: 'toast-unopened-progress'\n        })\n\n        response = false\n      }\n\n      callback(response)\n    }\n\n    if (window.FileReader) {\n      // If the browser has access to the File APIs, open the file\n      fileProcessor.openFile(file, processResults)\n    } else {\n      // If the browser can't access the File APIs, display a notification\n      toast.warn('Your browser is unable to open files.', {\n        autoClose: 5000,\n        className: 'toast-unopened',\n        bodyClassName: 'toast-unopened-body',\n        progressClassName: 'toast-unopened-progress'\n      })\n\n      response = false\n      callback(response)\n    }\n  }\n\n  // When a Subpattern variable is changed, create a new version of state\n  changeSelect (id, val, data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    newData.subpatterns[id].selected = val\n    return newData\n  }\n\n  // When a Subpattern is changed, create a new version of state\n  changeSubpattern (id, val, data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    newData.subpatterns[id].subpattern = val\n    return newData\n  }\n\n  // When a Subpattern is cleared, create a new version of state\n  clear (id, data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    newData.subpatterns.splice(id, 1)\n    return newData\n  }\n\n  // When a Subpattern is added, create a new version of state\n  add (data) {\n    let toUse = ''\n    const newData = JSON.parse(JSON.stringify(data))\n\n    // Identify the first unused Subpattern variable and select it\n    for (let i = 0; i < vars.length; i++) {\n      let used = false\n      for (let j = 0; j < newData.subpatterns.length; j++) {\n        if (newData.subpatterns[j].selected === vars[i]) {\n          used = true\n          break\n        } else {\n          continue\n        }\n      }\n      if (!used) {\n        toUse = vars[i]\n        break\n      } else {\n        continue\n      }\n    }\n\n    if (newData.subpatterns.length < vars.length) {\n      newData.subpatterns.push({ selected: toUse, subpattern: '' })\n    }\n\n    return newData\n  }\n\n  // When the pattern is changed, create a new version of state\n  changePattern (val, data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    newData.pattern = val\n    return newData\n  }\n\n  // When the number of desired words is changed, create a new version of state\n  wordNumChange (val, data) {\n    // Limit number entry to between 1 and 9999\n    if (val < 1) {\n      val = 1\n    } else if (val > 9999) {\n      val = 9999\n    }\n\n    // Only change state if the number is between 1 and 9999\n    if (val > 0 && val < 10000) {\n      const newData = JSON.parse(JSON.stringify(data))\n      newData.words = val\n      return newData\n    } else {\n      // Otherwise, keep state the same\n      return false\n    }\n  }\n\n  // If the selection for new lines is changed, create a new version of state\n  changeNewline (checked, data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    newData.newline = checked\n    return newData\n  }\n\n  // If the selection for filtering duplicates is changed, create a new version of state\n  changeDupes (checked, data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    newData.filterdupes = checked\n    return newData\n  }\n\n  // Check the input for errors\n  checkErrors (data) {\n    let status = []\n\n    // Check Subpattern for circular reference\n    const getSp = selected => {\n      let sp = ''\n      for (let i = 0; i < data.subpatterns.length; i++) {\n        if (data.subpatterns[i].selected === selected) {\n          sp = data.subpatterns[i].subpattern\n          break\n        }\n      }\n      return sp\n    }\n\n    const idDeps = subpattern => {\n      const deps = []\n      for (let i = 0; i < subpattern.length; i++) {\n        if (vars.includes(subpattern[i])) {\n          deps.push(subpattern[i])\n        }\n      }\n      return Array.from(new Set(deps))\n    }\n\n    const checkCirc = (selected, refed) => {\n      const sp = getSp(selected)\n      const deps = idDeps(sp)\n      let circ = false\n\n      if (deps.length > 0) {\n        if (deps.includes(selected) || refed.includes(selected)) {\n          circ = true\n        } else {\n          let i = 0\n          refed.push(selected)\n          while (!circ && i < deps.length) {\n            circ = checkCirc(deps[i], refed)\n            i++\n          }\n        }\n      }\n\n      return circ\n    }\n\n    for (let i = 0; i < data.subpatterns.length; i++) {\n      const deps = idDeps(data.subpatterns[i].subpattern)\n      const refed = []\n\n      if (deps.length > 0) {\n        for (let j = 0; j < deps.length; j++) {\n          if (checkCirc(deps[j], refed)) {\n            status.push('The Subpatterns contain a circular reference.')\n            break\n          }\n        }\n      }\n    }\n\n    // Check for duplicate Subpattern variable names\n    let duplicates = []\n    for (let i = 0; i < data.subpatterns.length; i++) {\n      const current = data.subpatterns[i].selected\n\n      for (let j = 0; j < data.subpatterns.length; j++) {\n        if (i === j) {\n          continue\n        } else {\n          if (data.subpatterns[j].selected === current) {\n            duplicates.push(current)\n          }\n        }\n      }\n    }\n\n    duplicates = Array.from(new Set(duplicates))\n    const dupes = duplicates.join(', ')\n\n    if (duplicates.length > 1) {\n      status.push(\n        `Some Subpattern variables (${dupes}) have been used multiple times.`\n      )\n    } else if (duplicates.length === 1) {\n      status.push(\n        `The Subpattern variable ${dupes} has been used multiple times.`\n      )\n    }\n\n    // Check Pattern for undefined variable\n    const defed = []\n    for (let i = 0; i < data.subpatterns.length; i++) {\n      defed.push(data.subpatterns[i].selected)\n    }\n\n    const undefed = []\n    for (let i = 0; i < data.pattern.length; i++) {\n      if (vars.includes(data.pattern[i])) {\n        if (!defed.includes(data.pattern[i])) {\n          undefed.push(data.pattern[i])\n        }\n      }\n    }\n    for (let i = 0; i < data.subpatterns.length; i++) {\n      for (let j = 0; j < data.subpatterns[i].subpattern.length; j++) {\n        if (vars.includes(data.subpatterns[i].subpattern[j])) {\n          if (!defed.includes(data.subpatterns[i].subpattern[j])) {\n            undefed.push(data.subpatterns[i].subpattern[j])\n          }\n        }\n      }\n    }\n\n    const undefSet = Array.from(new Set(undefed))\n    const undefs = undefSet.join(', ')\n\n    if (undefSet.length > 1) {\n      // Update this status message once escaping characters is enabled\n      status.push(\n        `Some capital A–Z letters (${undefs}) were used but not defined as variables. If your intention is to include these characters as a letter in the results, a future version will allow this using escaped characters.`\n      )\n    } else if (undefSet.length === 1) {\n      status.push(\n        `The capital letter ${undefs} was used but not defined as a variable. If your intention is to include this character as a letter in the results, a future version will allow this using escaped characters.`\n      )\n    }\n\n    status = Array.from(new Set(status))\n    return status\n  }\n\n  // Start the generation process\n  generate (data) {\n    const status = this.checkErrors(data)\n    let results\n\n    if (status.length > 0) {\n      results = {\n        status: status,\n        results: [],\n        stats: {\n          words: 0,\n          maxWords: 0,\n          filtered: 0,\n          remaining: 0\n        }\n      }\n    } else {\n      results = this.build(data, ['ok'])\n    }\n\n    return results\n  }\n\n  // Generate the output\n  build (data, status) {\n    const results = []\n    const newData = JSON.parse(JSON.stringify(data))\n\n    // Randomly choose from the items in an array\n    const chooseRand = length => {\n      return Math.floor(Math.random() * length)\n    }\n\n    // Get the subpattern for a variable\n    const getSubpattern = (subpatterns, selected) => {\n      let subpattern = []\n      for (let i = 0; i < subpatterns.length; i++) {\n        if (subpatterns[i].selected === selected) {\n          subpattern = subpatterns[i].subpattern\n          break\n        }\n      }\n      return subpattern\n    }\n\n    // If a chosen item is a defined variable, randomly choose from its own Subpattern\n    const resolveVar = (subpatterns, selected) => {\n      let letter = ''\n      if (vars.includes(selected)) {\n        const subpattern = getSubpattern(subpatterns, selected)\n        const selection = subpattern[chooseRand(subpattern.length)]\n        if (vars.includes(selection)) {\n          letter = resolveVar(subpatterns, selection)\n        } else {\n          letter = selection\n        }\n      } else {\n        letter = selected\n      }\n      if (letter.length > 1) {\n        letter = resolveOpt(subpatterns, letter)\n      }\n      return letter\n    }\n\n    const resolveOpt = (subpatterns, option) => {\n      let letters = ''\n      for (let i = 0; i < option.length; i++) {\n        if (/[()[\\]^*\"]/.test(option[i])) {\n          // For now, ignore the characters that will be used for operations\n          continue\n        } else {\n          letters += resolveVar(subpatterns, option[i])\n        }\n      }\n      return letters\n    }\n\n    // Split all the Subpatterns into arrays based on '/'\n    for (let i = 0; i < newData.subpatterns.length; i++) {\n      newData.subpatterns[i].subpattern = newData.subpatterns[\n        i\n      ].subpattern.split('/')\n    }\n\n    // Split the Pattern into an array based on '/'\n    const pattArr = newData.pattern.split('/')\n\n    // Generate the number of words requested in the settings\n    for (let i = 0; i < newData.words; i++) {\n      let word = ''\n\n      // If the Pattern has options, choose one\n      const patt = pattArr[chooseRand(pattArr.length)]\n\n      word += resolveOpt(newData.subpatterns, patt)\n\n      results.push(word)\n    }\n\n    // Calculate the stats on the generated output\n\n    // Calculate the maximum number of words\n    let count = 0\n\n    for (let i = 0; i < pattArr.length; i++) {\n      let optCount = 1\n      if (pattArr[i].length === 0) {\n        optCount = 0\n        break\n      } else {\n        for (let j = 0; j < pattArr[i].length; j++) {\n          const variab = pattArr[i][j]\n          let addCount = 0\n          let multCount = 1\n          if (/[()[\\]^*\"]/.test(variab)) {\n            // For now, ignore the characters that will be used for operations\n            continue\n          } else if (!vars.includes(variab)) {\n            // If the current item in the Pattern is not a variable, add 1 to the count\n            addCount += 1\n          } else {\n            for (let k = 0; k < newData.subpatterns.length; k++) {\n              const subpattern = newData.subpatterns[k]\n              if (subpattern.selected === variab) {\n                // If the variable is defined, count how many options are in the Subpattern\n                multCount *= subpattern.subpattern.length\n                break\n              } else {\n                // If the variable is unused, skip it\n                continue\n              }\n            }\n          }\n          optCount *= multCount\n          optCount += addCount\n        }\n      }\n      count += optCount\n    }\n\n    // If there are results, count how many words there are\n    let words = 0\n    if (results[0].length !== 0) {\n      words = results.length\n    }\n\n    const filteredWords = Array.from(new Set(results))\n    const remaining = filteredWords.length\n    const filtered = newData.words - remaining\n\n    const response = {\n      status: status,\n      results: results,\n      stats: {\n        words: words,\n        maxWords: count,\n        filtered: filtered,\n        remaining: remaining\n      }\n    }\n\n    return response\n  }\n}\n\nconst genService = new GenService()\n\nexport default genService\n","// extracted by mini-css-extract-plugin\nexport default {\"duplicate\":\"gen-module--duplicate--2vrZp\",\"subpsRow\":\"gen-module--subps-row--3zHFo\",\"addingRow\":\"gen-module--adding-row--1fmOe\",\"patternInput\":\"gen-module--pattern-input--2efCc\",\"subpatternInput\":\"gen-module--subpattern-input--siPud\",\"wordsInput\":\"gen-module--words-input--2Y2vR\",\"outText\":\"gen-module--out-text--SjdEj\"};","import React, { useState } from 'react'\nimport { graphql } from 'gatsby'\n\nimport Tool from '../../components/tool'\n\nimport GenForm from '../../pageComponents/gen/genForm'\nimport GenResults from '../../pageComponents/gen/genResults'\nimport genService from '../../services/genService'\n\nimport styles from './gen.module.sass'\n\nexport const pageQuery = graphql`\nquery GenToolQuery {\n  site {\n    siteMetadata {\n      toolInfo {\n        gen {\n          title\n          link\n          description\n        }\n      }\n    }\n  }\n}\n`\n\nconst Gen = props => {\n  const toolInfo = props.data?.site?.siteMetadata?.toolInfo?.gen\n\n  // State\n\n  const [subpatterns, setSubpatterns] = useState(\n    genService.getData().subpatterns\n  )\n  const [pattern, setPattern] = useState(genService.getData().pattern)\n  const [words, setWords] = useState(genService.getData().words)\n  const [newline, setNewline] = useState(genService.getData().newline)\n  const [filterdupes, setFilterdupes] = useState(\n    genService.getData().filterdupes\n  )\n  const [status, setStatus] = useState(['ok'])\n  const [results, setResults] = useState([''])\n  const [stats, setStats] = useState({\n    words: 0,\n    maxWords: 0,\n    filtered: 0,\n    remaining: 0\n  })\n\n  // Functions\n\n  const onChangeInput = e => {\n    const newdata = {\n      subpatterns,\n      pattern,\n      words,\n      newline,\n      filterdupes\n    }\n\n    if (e.target.tagName === 'BUTTON') {\n      e.preventDefault()\n      if (e.target.type === 'submit') {\n        // Generate the output\n        const response = genService.generate(newdata)\n        setStatus(response.status)\n        setResults(response.results)\n        setStats(response.stats)\n        // Save the current state to storage\n        genService.setStorage(newdata)\n      } else if (e.target.type === 'button') {\n        if (e.target.id === 'save') {\n          // Save the current state to storage and generate a file\n          genService.save(newdata)\n        } else if (e.target.id === 'add') {\n          // When the add button is clicked, add a blank Subpattern to state\n          setSubpatterns(genService.add(newdata).subpatterns)\n        } else if (e.target.id.slice(0, 1) === 'c') {\n          // When a Subpattern is cleared, delete the corresponding Subpattern from state\n          const id = e.target.id.slice(1)\n          setSubpatterns(genService.clear(id, newdata).subpatterns)\n        }\n      }\n    } else if (e.target.type === 'file') {\n      e.preventDefault()\n      // Open a file and parse it to restore a saved state\n      const file = e.target.files[0]\n      const updateState = response => {\n        if (response) {\n          // Only change state if the file was successfully opened\n          setSubpatterns(response.subpatterns)\n          setPattern(response.pattern)\n          setWords(response.words)\n          setNewline(response.newline)\n          setFilterdupes(response.filterdupes)\n        }\n      }\n      genService.open(file, updateState)\n    } else if (e.target.type === 'checkbox') {\n      const checked = e.target.checked\n      if (e.target.id === 'newline') {\n        // If the selection for new lines is changed, store that change in state\n        setNewline(genService.changeNewline(checked, newdata).newline)\n      } else if (e.target.id === 'filterdupes') {\n        // If the selection for filtering duplicates is changed, store that change in state\n        setFilterdupes(genService.changeDupes(checked, newdata).filterdupes)\n      }\n    } else {\n      const val = e.target.value\n      if (e.target.id === 'pattern') {\n        // When the pattern is changed, store the change in state\n        setPattern(genService.changePattern(val, newdata).pattern)\n      } else if (e.target.id === 'words') {\n        // When the number of desired words is changed, store that change in state\n        const response = genService.wordNumChange(val, newdata)\n        if (response) {\n          // Only update state if there's a change\n          setWords(response.words)\n        }\n      } else {\n        const id = e.target.id.slice(1)\n        const which = e.target.id.slice(0, 1)\n        if (which === 'v') {\n          // When a Subpattern variable is changed, store that change in state\n          setSubpatterns(genService.changeSelect(id, val, newdata).subpatterns)\n        } else if (which === 'p') {\n          // When a Subpattern is changed, store that change in state\n          setSubpatterns(\n            genService.changeSubpattern(id, val, newdata).subpatterns\n          )\n        }\n      }\n    }\n  }\n\n  return (\n    <Tool toolInfo={toolInfo}>\n      <GenForm\n        styles={styles}\n        data={{\n          subpatterns,\n          pattern,\n          words,\n          newline,\n          filterdupes\n        }}\n        change={onChangeInput}\n      />\n      <GenResults\n        styles={styles}\n        newline={newline}\n        filterDupes={filterdupes}\n        status={status}\n        results={results}\n        stats={stats}\n      />\n    </Tool>\n  )\n}\n\nexport default Gen\n"],"sourceRoot":""}