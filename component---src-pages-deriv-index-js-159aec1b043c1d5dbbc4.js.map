{"version":3,"sources":["webpack://langua/./src/pageComponents/deriv/derivForm.js","webpack://langua/./src/pageComponents/deriv/derivResults.js","webpack://langua/./src/services/derivService.js","webpack://langua/./src/pages/deriv/deriv.module.sass","webpack://langua/./src/pages/deriv/index.js"],"names":["styles","data","change","filePicker","React","lexemeRows","lexemes","map","lexeme","index","key","className","derivRow","type","id","name","lexemeInput","value","onChange","aria-label","lexemeDefInput","definition","clearButton","onClick","ver","small","derivationRows","derivations","derivation","derivationInput","derivationGlossInput","gloss","derivationDefInput","addButton","which","addingRow","classNames","sharedStyles","columnLabel","wordLabel","definitionLabel","affixLabel","glossLabel","addedClasses","side","htmlFor","min","max","wordsInput","words","e","preventDefault","current","click","ref","possible","results","useState","hovered","setHovered","outputBox","item","i","term","affixGloss","hoveredGloss","onMouseOver","hoverAffix","onMouseOut","unhoverAffix","lexGloss","output","newWords","length","newWord","outputRow","rowNumber","prefix","suffix","error","affixDef","hoveredDef","toLocaleString","this","getData","bind","save","open","setStorage","add","clear","changeInput","derive","dataProcessor","fileProcessor","file","callback","response","window","FileReader","result","endsWith","lexemeSchema","schema","String","derivationSchema","DataSchema","Number","Array","of","content","JSON","parse","toast","autoClose","bodyClassName","progressClassName","console","errors","newData","stringify","push","num","splice","val","wordNumChange","filter","remaining","affix","replace","test","match","circum","split","attachAffix","base","Math","floor","random","list","randInd","randAff","deriveFromSingleBase","der","randLex","deriveFromSingleDerivation","getUniqueItem","newItem","isUnique","deriveFromAny","PureDeriv","toolInfo","site","siteMetadata","deriv","derivService","setWords","setType","setLexemes","setDerivations","setResults","state","target","tagName","slice","idNum","files","props","useStaticQuery"],"mappings":"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","file":"component---src-pages-deriv-index-js-159aec1b043c1d5dbbc4.js","sourcesContent":["import React from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Form from '../../components/form'\nimport Button from '../../components/button'\nimport Control from '../../components/control'\nimport ControlSide from '../../components/control/side'\nimport ControlPiece from '../../components/control/piece'\n\nimport sharedStyles from '../../components/form/sharedForm.module.sass'\n\nconst DerivForm = ({ styles, data, change }) => {\n  const filePicker = React.createRef()\n\n  const lexemeRows = data.lexemes.map((lexeme, index) => (\n    <div key={index} className={styles.derivRow}>\n      <input\n        type='text'\n        id={`lw${index}`}\n        name={`lw${index}`}\n        className={styles.lexemeInput}\n        value={lexeme.lexeme}\n        onChange={change}\n        aria-label={`Word for lexeme ${index}`}\n      />\n      <input\n        type='text'\n        id={`ld${index}`}\n        name={`ld${index}`}\n        className={styles.lexemeDefInput}\n        value={lexeme.definition}\n        onChange={change}\n        aria-label={`Gloss for lexeme ${index}`}\n      />\n      <div className={styles.clearButton}>\n        <Button\n          id={`lc${index}`}\n          onClick={change}\n          ver='danger'\n          small\n          type='button'\n          aria-label={`Delete lexeme ${index}`}\n        >\n          Delete\n        </Button>\n      </div>\n    </div>\n  ))\n\n  const derivationRows = data.derivations.map((derivation, index) => (\n    <div key={index} className={styles.derivRow}>\n      <input\n        type='text'\n        id={`da${index}`}\n        name={`da${index}`}\n        className={styles.derivationInput}\n        value={derivation.derivation}\n        onChange={change}\n        aria-label={`Affix ${index}`}\n      />\n      <input\n        type='text'\n        id={`dl${index}`}\n        name={`dl${index}`}\n        className={styles.derivationGlossInput}\n        value={derivation.gloss}\n        onChange={change}\n        aria-label={`Gloss for affix ${index}`}\n      />\n      <input\n        type='text'\n        id={`dd${index}`}\n        name={`dd${index}`}\n        className={styles.derivationDefInput}\n        value={derivation.definition}\n        onChange={change}\n        aria-label={`Definition for affix ${index}`}\n      />\n      <div className={styles.clearButton}>\n        <Button\n          id={`dc${index}`}\n          onClick={change}\n          ver='danger'\n          small\n          type='button'\n          aria-label={`Delete lexeme ${index}`}\n        >\n          Delete\n        </Button>\n      </div>\n    </div>\n  ))\n\n  const addButton = which => (\n    <div className={styles.addingRow}>\n      <Button\n        onClick={change}\n        id={`${which}Add`}\n        ver='success'\n        small\n        type='button'\n      >\n        Add\n      </Button>\n    </div>\n  )\n\n  const invokeFilePicker = e => {\n    e.preventDefault()\n    filePicker.current.value = ''\n    filePicker.current.click()\n  }\n\n  return (\n    <Form name='deriv-form'>\n      <div className={classNames(styles.lexemes, sharedStyles.part)}>\n        <h5 className={sharedStyles.sectionTitle}>Lexemes</h5>\n        <div className={styles.derivRow}>\n          <h6 className={classNames(styles.columnLabel, styles.wordLabel)}>\n            Word\n          </h6>\n          <h6\n            className={classNames(styles.columnLabel, styles.definitionLabel)}\n          >\n            Gloss\n          </h6>\n        </div>\n        {lexemeRows}\n        {addButton('lex')}\n      </div>\n      <div className={classNames(styles.derivations, sharedStyles.part)}>\n        <h5 className={sharedStyles.sectionTitle}>Derivational Affixes</h5>\n        <div className={styles.derivRow}>\n          <h6 className={classNames(styles.columnLabel, styles.affixLabel)}>\n            Affix\n          </h6>\n          <h6 className={classNames(styles.columnLabel, styles.glossLabel)}>\n            Gloss\n          </h6>\n          <h6\n            className={classNames(styles.columnLabel, styles.definitionLabel)}\n          >\n            Definition\n          </h6>\n        </div>\n        {derivationRows}\n        {addButton('der')}\n      </div>\n      <Control addedClasses={sharedStyles.part}>\n        <ControlSide side='left'>\n          <ControlPiece>\n            <Button type='submit' ver='neutral' onClick={change}>\n              Derive\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <label htmlFor='words'>number of words to derive:</label>\n            <input\n              type='number'\n              id='words'\n              name='words'\n              min='1'\n              max='9999'\n              className={styles.wordsInput}\n              value={data.words}\n              onChange={change}\n            />\n          </ControlPiece>\n          <ControlPiece>\n            <label htmlFor='type'>output type:</label>\n            <select id='type' name='type' value={data.type} onChange={change}>\n              <option value='any'>any base, any derivation</option>\n              <option value='single base'>single base</option>\n              <option value='single derivation'>single derivation</option>\n            </select>\n          </ControlPiece>\n        </ControlSide>\n        <ControlSide side='right'>\n          <ControlPiece>\n            <Button id='save' ver='success' onClick={change} type='button'>\n              Save\n            </Button>\n          </ControlPiece>\n          <ControlPiece>\n            <Button id='open' onClick={invokeFilePicker} type='button'>\n              Open\n            </Button>\n            <input\n              id='file'\n              name='file'\n              className={sharedStyles.hidden}\n              type='file'\n              ref={filePicker}\n              onChange={change}\n            />\n          </ControlPiece>\n        </ControlSide>\n      </Control>\n    </Form>\n  )\n}\n\nDerivForm.propTypes = {\n  styles: PropTypes.object,\n  data: PropTypes.shape({\n    words: PropTypes.number.isRequired,\n    type: PropTypes.oneOf(['any', 'single base', 'single derivation'])\n      .isRequired,\n    lexemes: PropTypes.arrayOf(\n      PropTypes.shape({\n        lexeme: PropTypes.string.isRequired,\n        definition: PropTypes.string.isRequired\n      })\n    ),\n    derivations: PropTypes.arrayOf(\n      PropTypes.shape({\n        derivation: PropTypes.string.isRequired,\n        gloss: PropTypes.string.isRequired,\n        definition: PropTypes.string.isRequired\n      })\n    )\n  }).isRequired,\n  change: PropTypes.func.isRequired\n}\n\nexport default DerivForm\n","import React, { useState } from 'react'\nimport classNames from 'classnames'\nimport PropTypes from 'prop-types'\n\nimport Results from '../../components/results'\n\nimport sharedStyles from '../../components/results/sharedResults.module.sass'\n\nconst DerivResults = ({ styles, results }) => {\n  const [hovered, setHovered] = useState(null)\n  const outputBox = (which, item, i) => {\n    if (which === 'affix') {\n      return (\n        <div className={styles.outputBox}>\n          <p className={styles.term}>{item.derivation}</p>\n          <p\n            className={classNames(\n              styles.affixGloss,\n              styles.gloss,\n              // Dynamically assign the hovered class if hovered\n              i === hovered ? styles.hoveredGloss : null\n            )}\n            onMouseOver={() => hoverAffix(i)}\n            onMouseOut={() => unhoverAffix(i)}\n          >\n            {item.gloss}\n          </p>\n        </div>\n      )\n    } else if (which === 'lexeme') {\n      return (\n        <div className={styles.outputBox}>\n          <p className={styles.term}>{item.lexeme}</p>\n          <p className={classNames(styles.lexGloss, styles.gloss)}>\n            {item.definition}\n          </p>\n        </div>\n      )\n    } else if (which === 'error') {\n      return (\n        <div className={styles.outputBox}>\n          <p className={classNames(sharedStyles.error, styles.gloss)}>{item}</p>\n        </div>\n      )\n    } else {\n      return null\n    }\n  }\n\n  const output = () => {\n    if (results) {\n      if (results.newWords.length) {\n        return results.newWords.map((newWord, i) => (\n          <div\n            key={i}\n            className={classNames(styles.derivRow, styles.outputRow)}\n          >\n            <div className={classNames(styles.outputBox, styles.rowNumber)}>\n              {i + 1}.\n            </div>\n            <div>\n              <div className={classNames(styles.derivRow, styles.outputRow)}>\n                {newWord.prefix ? outputBox('affix', newWord.prefix, i) : null}\n                {newWord.lexeme ? outputBox('lexeme', newWord.lexeme, i) : null}\n                {newWord.suffix ? outputBox('affix', newWord.suffix, i) : null}\n                {newWord.error ? outputBox('error', newWord.error, i) : null}\n              </div>\n              <p\n                className={classNames(\n                  styles.affixDef,\n                  // Dynamically assign the hovered class if hovered\n                  i === hovered ? styles.hoveredDef : null\n                )}\n              >\n                {newWord.prefix\n                  ? newWord.prefix.definition\n                  : newWord.suffix\n                  ? newWord.suffix.definition\n                  : ''}\n              </p>\n            </div>\n          </div>\n        ))\n      }\n    }\n\n    return null\n  }\n\n  const statsText = () => {\n    let words = 0\n    let possible = 0\n\n    if (results) {\n      words = results.newWords.length.toLocaleString()\n      possible = results.possible.toLocaleString()\n    }\n\n    return `words: ${words}; maximum derivations possible: ${possible}`\n  }\n\n  const hoverAffix = i => {\n    setHovered(i)\n  }\n\n  const unhoverAffix = i => {\n    setHovered(null)\n  }\n\n  return (\n    <Results>\n      <div className={styles.output}>{output()}</div>\n      <div className={sharedStyles.stats}>\n        <p className={sharedStyles.statsText}>{statsText()}</p>\n      </div>\n    </Results>\n  )\n}\n\nDerivResults.propTypes = {\n  styles: PropTypes.object,\n  results: PropTypes.shape({\n    newWords: PropTypes.arrayOf(\n      PropTypes.shape({\n        lexeme: PropTypes.shape({\n          lexeme: PropTypes.string.isRequired,\n          definition: PropTypes.string.isRequired\n        }).isRequired,\n        prefix: PropTypes.shape({\n          derivation: PropTypes.string.isRequired,\n          gloss: PropTypes.string.isRequired,\n          definition: PropTypes.string.isRequired\n        }),\n        suffix: PropTypes.shape({\n          derivation: PropTypes.string.isRequired,\n          gloss: PropTypes.string.isRequired,\n          definition: PropTypes.string.isRequired\n        }),\n        error: PropTypes.string\n      })\n    ),\n    possible: PropTypes.number\n  })\n}\n\nexport default DerivResults\n","import { toast } from 'react-toastify'\nimport schema from 'js-schema'\n\nimport dataProcessor from '../tools/dataProcessor'\nimport fileProcessor from '../tools/fileProcessor'\n\nclass DerivService {\n  constructor () {\n    this.item = 'deriv'\n    this.getData = this.getData.bind(this)\n    this.save = this.save.bind(this)\n    this.open = this.open.bind(this)\n    this.setStorage = this.setStorage.bind(this)\n    this.add = this.add.bind(this)\n    this.clear = this.clear.bind(this)\n    this.changeInput = this.changeInput.bind(this)\n    this.derive = this.derive.bind(this)\n  }\n\n  // Get the data from storage or from the default data\n  getData () {\n    return dataProcessor.getData(this.item)\n  }\n\n  // Store the current data in storage\n  setStorage (data) {\n    dataProcessor.setStorage(data, this.item)\n  }\n\n  // Save the current state to storage and generate a file\n  save (data) {\n    fileProcessor.save(data, this.item)\n  }\n\n  // Open a file and parse it to restore a saved state\n  open (file, callback) {\n    let response\n\n    const processResults = result => {\n      // If correct filetype\n      if (file.name.endsWith('.lngd')) {\n        // Define correct file structure\n        const lexemeSchema = schema({\n          lexeme: String,\n          definition: String\n        })\n\n        const derivationSchema = schema({\n          derivation: String,\n          gloss: String,\n          definition: String\n        })\n\n        const DataSchema = schema({\n          words: Number,\n          type: ['any', 'single base', 'single derivation'],\n          lexemes: Array.of(lexemeSchema),\n          derivations: Array.of(derivationSchema)\n        })\n\n        const content = JSON.parse(result)\n\n        if (content.results) {\n          content.results.words = +content.results.words\n        }\n\n        if (DataSchema(content)) {\n          // If the file's content contains valid Data, load it\n          toast.success(`Data loaded from ${file.name}.`, {\n            autoClose: 5000,\n            className: 'toast-opened',\n            bodyClassName: 'toast-opened-body',\n            progressClassName: 'toast-opened-progress'\n          })\n\n          this.setStorage(content)\n\n          response = content\n        } else {\n          // If the file's content does not contain valid Data, show an error\n          toast.warn(`The content of ${file.name} is invalid.`, {\n            autoClose: 5000,\n            className: 'toast-unopened',\n            bodyClassName: 'toast-unopened-body',\n            progressClassName: 'toast-unopened-progress'\n          })\n\n          // eslint-disable-next-line\n          console.error(DataSchema.errors(content))\n\n          response = false\n        }\n      } else {\n        // If incorrect filetype\n        toast.warn('Wrong filetype selected.', {\n          autoClose: 5000,\n          className: 'toast-unopened',\n          bodyClassName: 'toast-unopened-body',\n          progressClassName: 'toast-unopened-progress'\n        })\n\n        response = false\n      }\n\n      callback(response)\n    }\n\n    if (window.FileReader) {\n      // If the browser has access to the File APIs, open the file\n      fileProcessor.openFile(file, processResults)\n    } else {\n      // If the browser can't access the File APIs, display a notification\n      toast.warn('Your browser is unable to open files.', {\n        autoClose: 5000,\n        className: 'toast-unopened',\n        bodyClassName: 'toast-unopened-body',\n        progressClassName: 'toast-unopened-progress'\n      })\n\n      response = false\n      callback(response)\n    }\n  }\n\n  // Add a new row to the form\n  add (data, which) {\n    const newData = JSON.parse(JSON.stringify(data))\n    if (which === 'lex') {\n      newData.lexemes.push({ lexeme: '', definition: '' })\n    } else {\n      newData.derivations.push({ derivation: '', gloss: '', definition: '' })\n    }\n    return newData\n  }\n\n  // Remove a row from the form\n  clear (data, num, which) {\n    const newData = JSON.parse(JSON.stringify(data))\n    if (which === 'l') {\n      newData.lexemes.splice(num, 1)\n    } else {\n      newData.derivations.splice(num, 1)\n    }\n    return newData\n  }\n\n  // Update an input field\n  changeInput (data, num, which, val) {\n    const newData = JSON.parse(JSON.stringify(data))\n    switch (which) {\n      case 'lw':\n        newData.lexemes[num].lexeme = val\n        break\n      case 'ld':\n        newData.lexemes[num].definition = val\n        break\n      case 'da':\n        newData.derivations[num].derivation = val\n        break\n      case 'dl':\n        newData.derivations[num].gloss = val\n        break\n      case 'dd':\n        newData.derivations[num].definition = val\n        break\n      default:\n        break\n    }\n    return newData\n  }\n\n  // When the number of desired words is changed, create a new version of state\n  wordNumChange (data, val) {\n    val = +val\n    // Limit number entry to between 1 and 9999\n    if (val < 1) {\n      val = 1\n    } else if (val > 9999) {\n      val = 9999\n    }\n\n    // Only change state if the number is between 1 and 9999\n    if (val > 0 && val < 10000) {\n      const newData = JSON.parse(JSON.stringify(data))\n      newData.words = val\n      return newData\n    } else {\n      // Otherwise, keep state the same\n      return false\n    }\n  }\n\n  // Derive words from the data\n  derive (data) {\n    const newData = JSON.parse(JSON.stringify(data))\n    // Compute the total possible number of results\n    const computePossible = filter => {\n      if (filter === 'single base') {\n        return newData.derivations.length\n      } else if (filter === 'single derivation') {\n        return newData.lexemes.length\n      } else {\n        return newData.lexemes.length * newData.derivations.length\n      }\n    }\n    const possible = computePossible(newData.type)\n    // If the user has selected to derive more than the total number possible, limit the results to the number that is possible\n    let remaining = newData.words > possible ? possible : newData.words\n\n    // Classify each of the affixes\n    const derivations = newData.derivations.map(affix => {\n      affix.derivation = affix.derivation.replace(/-+/g, '-')\n      if (/-/.test(affix.derivation)) {\n        // If the affix entered contains a hyphen\n        if (affix.derivation.match(/-/g).length === 1) {\n          // If the affix entered caintains no more than one hyphen\n          if (/-$/.test(affix.derivation)) {\n            // Prefix\n            affix.gloss = `${affix.gloss}-`\n            return { prefix: affix }\n          } else if (/^-/.test(affix.derivation)) {\n            // Suffix\n            affix.gloss = `-${affix.gloss}`\n            return { suffix: affix }\n          } else {\n            // Circumfix\n            const circum = affix.derivation.split(/-/)\n            const prefix = JSON.parse(JSON.stringify(affix))\n            const suffix = JSON.parse(JSON.stringify(affix))\n            prefix.derivation = `${circum[0]}-`\n            prefix.gloss = `${prefix.gloss}-`\n            suffix.derivation = `-${circum[1]}`\n            suffix.gloss = `-${suffix.gloss}`\n            return { prefix: prefix, suffix: suffix }\n          }\n        } else {\n          // If the affix entered contains more than one hyphen\n          return {\n            error: `The affix ${affix.derivation} contains too many hyphens.`\n          }\n        }\n      } else {\n        // If the affix entered contains no hyphens\n        return { error: `The affix ${affix.derivation} is missing a hyphen.` }\n      }\n    })\n\n    // Attach words to their affixes on the correct side(s)\n    const attachAffix = (lexeme, affix) => {\n      return {\n        prefix: affix.prefix,\n        lexeme: lexeme,\n        suffix: affix.suffix,\n        error: affix.error\n      }\n    }\n\n    // Derive from a single base\n    const deriveFromSingleBase = () => {\n      const base =\n        newData.lexemes[Math.floor(Math.random() * newData.lexemes.length)]\n      const list = []\n      while (remaining > 0) {\n        const randInd = Math.floor(Math.random() * derivations.length)\n        const randAff = derivations[randInd]\n        list.push(attachAffix(base, randAff))\n        derivations.splice(randInd, 1)\n        remaining--\n      }\n      return list\n    }\n\n    // Derive from a single derivation\n    const deriveFromSingleDerivation = () => {\n      const der = derivations[Math.floor(Math.random() * derivations.length)]\n      const list = []\n      while (remaining > 0) {\n        const randInd = Math.floor(Math.random() * newData.lexemes.length)\n        const randLex = newData.lexemes[randInd]\n        list.push(attachAffix(randLex, der))\n        newData.lexemes.splice(randInd, 1)\n        remaining--\n      }\n      return list\n    }\n\n    // Derive from any base and any derivation\n    const deriveFromAny = () => {\n      const list = []\n      // Find only unique pairs of lexemes and affixes\n      const getUniqueItem = () => {\n        const randLex =\n          newData.lexemes[Math.floor(Math.random() * newData.lexemes.length)]\n        const randAff =\n          derivations[Math.floor(Math.random() * derivations.length)]\n        let newItem = attachAffix(randLex, randAff)\n        let isUnique = true\n        for (let i = 0; i < list.length; i++) {\n          if (JSON.stringify(newItem) === JSON.stringify(list[i])) {\n            isUnique = false\n            break\n          }\n        }\n        if (!isUnique) {\n          newItem = getUniqueItem()\n        }\n        return newItem\n      }\n      while (remaining > 0) {\n        list.push(getUniqueItem())\n        remaining--\n      }\n      return list\n    }\n\n    if (newData.type === 'single base') {\n      return { newWords: deriveFromSingleBase(), possible: possible }\n    } else if (newData.type === 'single derivation') {\n      return { newWords: deriveFromSingleDerivation(), possible: possible }\n    } else {\n      return { newWords: deriveFromAny(), possible: possible }\n    }\n  }\n}\n\nconst derivService = new DerivService()\n\nexport default derivService\n","// extracted by mini-css-extract-plugin\nexport default {\"wordsInput\":\"deriv-module--words-input--3_pLI\",\"derivRow\":\"deriv-module--deriv-row--1FFeo\",\"addingRow\":\"deriv-module--adding-row--sX2At\",\"outputRow\":\"deriv-module--output-row--3vdh4\",\"columnLabel\":\"deriv-module--column-label--35gi5\",\"lexemeInput\":\"deriv-module--lexeme-input--16dBy\",\"wordLabel\":\"deriv-module--word-label--1lbrW\",\"derivationGlossInput\":\"deriv-module--derivation-gloss-input--2GHha\",\"glossLabel\":\"deriv-module--gloss-label--1Z2GZ\",\"lexemeDefInput\":\"deriv-module--lexeme-def-input--2xyWj\",\"definitionLabel\":\"deriv-module--definition-label--NOxBT\",\"derivationDefInput\":\"deriv-module--derivation-def-input--3ZtSX\",\"derivationInput\":\"deriv-module--derivation-input--22_N2\",\"affixLabel\":\"deriv-module--affix-label--1h9ZC\",\"outputBox\":\"deriv-module--output-box--1WN2x\",\"rowNumber\":\"deriv-module--row-number--1EVu1\",\"term\":\"deriv-module--term--MwRlp\",\"gloss\":\"deriv-module--gloss--2Y62Y\",\"lexGloss\":\"deriv-module--lex-gloss--2o52m\",\"affixGloss\":\"deriv-module--affix-gloss--EICTR\",\"affixDef\":\"deriv-module--affix-def--xtHjE\",\"hoveredGloss\":\"deriv-module--hovered-gloss--3Fqw9\",\"hoveredDef\":\"deriv-module--hovered-def--Ozs0j\"};","import React, { useState } from 'react'\nimport { graphql, useStaticQuery } from 'gatsby'\n\nimport Tool from '../../components/tool'\n\nimport DerivForm from '../../pageComponents/deriv/derivForm'\nimport DerivResults from '../../pageComponents/deriv/derivResults'\nimport derivService from '../../services/derivService'\n\nimport styles from './deriv.module.sass'\n\nexport const PureDeriv = ({ data }) => {\n  const toolInfo = data?.site?.siteMetadata?.toolInfo?.deriv\n\n  // State\n\n  const [words, setWords] = useState(derivService.getData().words)\n  const [type, setType] = useState(derivService.getData().type)\n  const [lexemes, setLexemes] = useState(derivService.getData().lexemes)\n  const [derivations, setDerivations] = useState(\n    derivService.getData().derivations\n  )\n  const [results, setResults] = useState(derivService.getData().results)\n\n  // Functions\n\n  const onChange = e => {\n    const state = { words, type, lexemes, derivations, results }\n    if (e.target.tagName === 'BUTTON') {\n      e.preventDefault()\n      if (e.target.type === 'submit') {\n        // Derive the output\n        const response = derivService.derive(state)\n        state.results = response\n        setResults(response)\n        // Save the current state to storage\n        derivService.setStorage(state)\n      } else if (e.target.id === 'save') {\n        // Save the current state to storage and generate a file\n        derivService.save(state)\n      } else if (e.target.id.slice(3) === 'Add') {\n        const which = e.target.id.slice(0, 3)\n        // When the add button is clicked, add a blank row to state\n        const newData = derivService.add(state, which)\n        setLexemes(newData.lexemes)\n        setDerivations(newData.derivations)\n      } else if (e.target.id.slice(1, 2) === 'c') {\n        // When a row is cleared, delete teh corresponding row from state\n        const idNum = e.target.id.slice(2)\n        const which = e.target.id.slice(0, 1)\n        const newData = derivService.clear(state, idNum, which)\n        setLexemes(newData.lexemes)\n        setDerivations(newData.derivations)\n      }\n    } else if (e.target.type === 'file') {\n      e.preventDefault()\n      // Open a file and parse it to restore saved state\n      const file = e.target.files[0]\n      const updateState = response => {\n        if (response) {\n          // Only change state if the file was successfully opened\n          setWords(response.words)\n          setType(response.type)\n          setLexemes(response.lexemes)\n          setDerivations(response.derivations)\n          setResults(response.results)\n        }\n      }\n\n      derivService.open(file, updateState)\n    } else {\n      const idNum = e.target.id.slice(2)\n      const which = e.target.id.slice(0, 2)\n      const val = e.target.value\n      const name = e.target.name\n      if (\n        which === 'lw' ||\n        which === 'ld' ||\n        which === 'da' ||\n        which === 'dl' ||\n        which === 'dd'\n      ) {\n        const response = derivService.changeInput(state, idNum, which, val)\n        if (response) {\n          // Only change state if the input was successfully changed\n          setWords(response.words)\n          setType(response.type)\n          setLexemes(response.lexemes)\n          setDerivations(response.derivations)\n          setResults(response.results)\n        }\n      } else if (name === 'words') {\n        const response = derivService.wordNumChange(state, val)\n        if (response) {\n          // Only change state if the word number was successfully changed\n          setWords(response.words)\n          setType(response.type)\n          setLexemes(response.lexemes)\n          setDerivations(response.derivations)\n          setResults(response.results)\n        }\n      } else {\n        if (name === 'type') {\n          setType(val)\n        }\n      }\n    }\n  }\n\n  return (\n    <Tool toolInfo={toolInfo}>\n      <DerivForm\n        styles={styles}\n        data={{ words, type, lexemes, derivations }}\n        change={onChange}\n      />\n      <DerivResults styles={styles} results={results} />\n    </Tool>\n  )\n}\n\nconst Deriv = props => {\n  const data = useStaticQuery(graphql`\n    query DerivToolQuery {\n      site {\n        siteMetadata {\n          toolInfo {\n            deriv {\n              title\n              link\n              description\n            }\n          }\n        }\n      }\n    }\n  `)\n\n  return <PureDeriv {...props} data={data} />\n}\n\nexport default Deriv\n"],"sourceRoot":""}